<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- Begin Document Specific Declarations -->
<!-- End Document Specific Declarations -->
<html>
<head>
<title>PIA Application Author's Guide</title>
</head>
<body>
<center>
<h1>PIA Application Author's Guide</h1>
</center>

<p> This document provides an overview of  application writing in the
    PIA system. In particular it describes:
</p>

<font color="red" size="+4"> Steve-- assume anything outside a blockquote has
been messed with and potentially screwed up.  </font>


<ul>
<li><a href="#Quick">Quick Start</a></li>

<li><a href="#Naming">Application naming</a></li>

<li><a href="#Types">Application types</a></li>

<li><a href="#Files">Application files</a></li>

<li><a href="#Code">Application data structures and code</a></li>

<li><a href="#Tips">Tips on application creation</a></li>
</ul>


<p>Active pages for sample applications are in the <code>/PIA/Agents/</code>
and <code>PIA/Samples/</code> directories. Feel free to use these files as a
source of ideas and examples, and as a basis for creating new applications.</p>

<h2><a name="Quick"></a>Quick Start</h2>

<ul>
<li><p>
 Browse to  the subsites in the <code>Samples/</code> directory.  Find one
 upon which you might like to build, and copy that directory and its contents
into the <code>.pia/</code> (or <code>$PIA_ROOT/</code>) directory, under a
new name (e.g. <code>cp -r ~/PIA/Samples/HelloWorld/ ~/.pia/MyApps/MyFirstPage
</code> ).  Now any changes you make will not be confused with files in the
original source-tree, nor overwritten upon updating via CVS.  And any files
your active pages write or read will appear in (or relative to) this new
directory.</p> </li>

<li><p> In this new directory, change every occurrence of the original name
(<code>HelloWorld</code>) to the new one (<code>MyFirstPage</code>), both
filenames and file content. This ensures that you don't have any stray
references to the original application, and that any proper configurations and
tagsets are used.
</p></li>

          
<li><p> Add some text to the copied <code>home.xh</code> file, and aim your
    browser at the new page
    (e.g.<code> http://myHost:8888/MyApps/MyFirstPage/home.xh </code>)... you
    should see the text.  
</p></li>

<li><p> Define a new tag at the very top of <code>home.xh</code> (as happens
   at the top of <code>HelloWorld/home.xh</code>), and use the tag in the
   body.  Refresh the broswer page (<code>shift-Reload</code>) to see the
   effects.  If you expect to create many such tags, or to use them in other
   pages, you should move them into a tagset file (see--or copy!-- the
   <code>TagsetDemo/</code> sample to see how). </p></li>

<li><p> Add a <code>&lt;show-errors /&gt;</code> tag to your page to indicate
any errors which may occur.  Try the <code>&lt;pretty /&gt;</code> tag to see
the structure of your XML.  Check out the <a
	 href="http://pia.rsv.ricoh.com/Tutorial/home.xh"> hackable tutorials
	 </a> for more explanation of how such tags work. Play around!</p></li>

</ul>


<blockquote>
<h2><a name="Naming"></a>Application Naming and Directories</h2>


<strong>=== THIS SECTION IS ENTIRELY WRONG!===</strong>

<p> Every application has a <em>name</em> and a <em>path</em>.  The file portion of
    the application's URL consists of the path and name concatenated together; the
    path always begins and ends with the slash (<code>/</code>) character (and
    may consist of only one slash, and nothing else).  The combination of path
    and name is called the application's <em>pathname</em>. 
</p>

<p> An application's pathname can be combined with the tilde (<code>~</code>)
    character in various ways to address its four directories:  root, home,
    user, and data.  (In most cases the root and home directories are the
    same.)
</p>

<p> The base directories PIA_HOME and PIA_ROOT can be set on the
    <code>pia</code> command line or in the corresponding environment
    variables.  They are normally the root of the PIA directory tree (called
    PIA and located wherever the PIA is installed in your system) and (on
    Unix) a directory called <code>.pia</code> in your home directory.
</p>

<p> In the table that follows, the leading and trailing slashes of the path
    are shown explicitly for clarity. 
</p>

<table width="90%" align=center border=1>
  <tr> <th align=left> URL </th>
	<th align=left> Default Directory </th>
	<th align=left> Entity </th>
       <th align=left> Description </th>
  </tr>
  <tr> <td> <code>/<em>path</em>/<em>name</em></code>  			</td>
       <td> <code>PIA_HOME/Agents/<em>path</em>/<em>name</em></code> 	</td> 
       <td> &nbsp; 		</td>
       <td> root directory 	</td>
  </tr>
  <tr> <td> <code>/<em>path</em>/<em>name</em>~</code> 			</td>
       <td> <code>PIA_HOME/Agents/<em>path</em>/<em>name</em></code> 	</td> 
       <td> AGENT:home-dir 	</td>
       <td> home directory 	</td>
  </tr>
  <tr> <td> <code>/<em>path</em>/<em>name</em>/~</code> 		</td>
       <td> <code>PIA_ROOT/<em>path</em>/<em>name</em></code> 		</td>
       <td> AGENT:data-dir  	</td>
       <td> data directory 	</td>
  </tr>
  <tr> <td> <code>/~<em>name</em></code> 		</td>
       <td> <code>PIA_ROOT/<em>path</em>/<em>name</em></code> 		</td>
       <td> AGENT:data-dir  	</td>
       <td> data directory (deprecated)	</td>
  </tr>
  <tr> <td> <code>/~/Agents/<em>path</em>/<em>name</em></code> 		</td>
       <td> <code>PIA_ROOT/Agents/<em>path</em>/<em>name</em></code> 	</td>
       <td> AGENT:user-dir 	</td>
       <td> data directory 	</td>
  </tr>
  <tr> <td> <code>/~/<em>path</em>/<em>name</em>~</code> 		</td>
       <td> <code>PIA_ROOT/<em>path</em>/<em>name</em></code> 		</td>
       <td> AGENT:data-dir 	</td>
       <td> data directory 	</td>
  </tr>
</table>

<p> The paths involving <code>/~/</code> are simply a consequence of the fact
    that the ROOT agent's root directory is its data directory, and is mapped
    to the PIA data directory.  There is normally no way to address the user
    directory directly; files in it simply override (replace) corresponding
    files in the home directory.
</p>

<p> The path <code>/~<em>name</em></code> is an older construct; it's
    ambiguous if the path starts with the name of some other agent.  It is
    still useful, however, because it follows the standard convention for
    ``user directories'' on Unix systems and the Web.  You could, for example,
    define an agent with your login name as its name; its data directory would
    then look like your web home page.
</p>

<p> By convention, agent names intended to be seen at the top level of an
    agent listing are capitalized, but this is not required. Name lookup is
    case-sensitive, and there may be good reasons to prefer uppercase or
    lowercase names in some cases. For example, DOFS is uppercase because it
    is an acronym. Most agents with DOFS as their type have names that match
    their corresponding root directory; for example, <code>/PIA</code>.  For
    another example, <code>fileTools</code> and <code>remoteTools</code> are
    sub-agents of <code>Proxie/Toolbar</code>, and so have lowercase names.
</p>

<p> For historical reasons, it is currently possible to address an agent by
    its name (for example, <code>/<em>name</em></code> for the home directory)
    even if it has a non-null path.  This will eventually disappear.
</p>



</blockquote>
<font color="red">
Bill's proposal here

<p> Every application (or "subsite") lives in a directory. In the simplest
    case, the directory has the same name as the application and is located
    under <var>PIA_ROOT/</var>.  For instance, the example in the Quick-start
    section above creates the <code>MyFirstPage</code> application in the
    directory <var>.pia/MyApps/MyFirstPage</var>.  Also, the applications we
    provide are in same-named directories under <var>PIA/Agents</var> and
    <var>PIA/Samples</var>. Various configuration files
    (<var>_subsite.xcf</var>) could tell the processor to look for the
    application in other directories instead. </p>

    <p>But in all cases, the application's URL always <i>looks</i> as if the
    application resides directly under the URL's root (the "slash" after the
    port number). So, for example, the <code>MyFirstPage</code> URL would be
    <var>http://piaHOST:8888/MyApps/MyFirstPage</var>, and the
    <code>HelloWorld</code> URL would be
    <var>http://piaHOST:8888/Samples/HelloWorld</var>, with no indication that
    one lives under <var>.pia/</var> and the other under <var>PIA/</var>. </p>

    <p> The procesor has internal rules for deciding where to look for files
	belonging to given a URL (in this example, the rule is "look in
	<var>.pia/</var> before looking in <var>PIA/</var>").  But you can add
	more rules via the configuration files, so that an application's
	active pages, tagsets, subdirectories and so forth can reside
	<i>anywhere</i>; you just need to make sure that a (real)
	<var>_subsite.xcf</var> file under <var>PIA_ROOT</var> or
	<var>PIA_HOME</var> tells the processor where the "anywhere" is. </p>


<p> Even the base directories <var>PIA_HOME</var> and <var>PIA_ROOT</var> can
    be set on the <code>pia</code> command line or in the corresponding
    environment variables.  They are normally the root of the PIA directory
    tree (called PIA and located wherever the PIA is installed in your system)
    and  a directory called <code>.pia</code> in your home directory.
</p>

</font>



<blockquote>

============= This section is questionable ================

<h2><a name="Types">Agent Types</a></h2>

<p>Every agent also has a <em>type</em>, which can be 
used to create a family of agents with similar behavior but
different options. The <a href="/DOFS">DOFS</a> agents form such a
family. So do the <a href="/Toolbar">&Toolbar;</a> agents <a href= 
'/remoteTools/'>remoteTools</a> and <a href='/fileTools/'>
fileTools</a>. In most case, the type classification name
represents not only the family name but names an agent of which the
others are "sub-agents."</p>

<p> To be specific, the type is the complete pathname of an agent from which
    files are ``inherited''.  An agent will search for files first in its user
    directory, then its home directory, and then in the directories of its
    type agent.  An agent without a type will finally look in the
    <code>Agent</code> subdirectories of PIA_ROOT and PIA_HOME.
</p>

<p> Agents that are not "sub-agents" of some type have their type the same as
    their name.  An XHTML script can verify this with the following test:
</p>

<blockquote><code>&lt;test exact
match="&amp;AGENT:name;&gt;"&amp;AGENT:type;&lt;/test&gt;</code></blockquote>

</blockquote>




<font color="red">
bill's proposal here

<h2><a name="Types">Application Types</a></h2>

<p> There are roughly two kinds of applications: passive and active.  Passive
    applications "just sit there," doing nothing until a request for a page
    comes in... at which point the processor finds the right page, processes
    the appropriate <var>.xh</var> file, and sends back the processed
    results. This is like a traditional static web-page or CGI script.</p>

  <p>Active applications, on the other hand, are more like "Agents" in the
  traditional sense: they are background processes, always on, which eavesdrop
  on and potentially modify all the port's traffic.  For example, the
  <var>History</var> application (under <var>Agents/</var>) keeps track of
  every URL visited, and the <var>Proxie</var> application modifies incoming
  HTML according to the user's customization rules.  This is like a
  traditional proxy-browser or proxy-server. </p>

   <p> The prototype applications in <var>Samples/</var> are of the passive
       type; it is best to get accustomed to using these before tinkering with
       the more subtle and complex active ones.  Once you are ready, look at
       <var>PIA/Agents/Proxie</var> as a prototype active appliation. </p>

</font>

<blockquote>

============== This section is questionable ================

<h2><a name="Files"></a>Agent Files</h2>

<p>This section describes the files that make up an agent.</p>

<h3>File Names</h3>

<p> Unlike most web servers, the PIA does not require filename extensions
    (also called ``suffixes'' or, in Windows, ``filetypes'').  This makes it
    possible to refer to a document without revealing to the user whether it
    is an ordinary HTML file or is created on-the-fly from an active document.
    It also makes URL's shorter (and hence easier to remember). 
</p>

<p> Documents in an agent's home and user directories are looked up with
    a different (larger) set of suffixes from files in the data directory;
    this reflects the fact that active documents are not permitted in the data
    directory, for security reasons.
</p>

<p> A file's extension, as usual, determines its MIME type.  For active
    documents, it also determines the tagset used to process the file:
</p>

<table>
  <tr><th> &nbsp; </th>
      <th> tagset </th>
      <th> meaning </th>
  </tr>
  <tr><th> .xh </th> <td> xhtml </td>
      <td> Extended HTML </td>
  </tr>
  <tr><th> .xx </th> <td> xxml </td>
      <td> Extended XML </td>
  </tr>
  <tr><th> .html </th> <td> html </td>
      <td> Ordinary HTML </td>
  </tr>
  <tr><th> .htm </th> <td> html </td>
      <td> Ordinary HTML </td>
  </tr>
  <tr><th> .xml </th> <td> <em>none</em> </td>
      <td> Ordinary XML </td>
  </tr>

  <tr><th colspan=2>&nbsp;</th><th>&nbsp;</th></tr>

  <tr><th colspan=2>&nbsp;</th>
      <th> (used internally) </th>
  </tr>

  <tr><th> .inc </th> <td> xhtml </td>
      <td> ``include'' files </td>
  </tr>
  <tr><th> .ts </th> <td> tagset </td>
      <td> tagset files </td>
  </tr>
  <tr><th> .xml </th> <td> depends on usage. </td>
      <td> Ordinary XML </td>
  </tr>
</table>

<p> File names passed to the PIA in URL's are always handled by the
    appropriate agent.  Relative filenames always have the current base
    (pathname) prepended by the browser.
</p>

<p> Inside the PIA things are somewhat more complex: there are two additional
    contexts to consider.  These are the form fields used during agent
    initialization, and the attributes that designate system resources:
    ``<code>src</code>'' in the &lt;include&gt;, &lt;connect&gt;, and
    &lt;status&gt; elements, and the ``system names'' of entities.  The
    following conventions are used for agent initialization:
</p>

<!-- === the following table is totally wrong now! === -->
<table>
  <tr><td> <code>~/</code></td>
      <td> The user's home directory </td>
  <tr><td> <code>./</code></td>
      <td> (or any relative path) the PIA agent directory</td>
  <tr><td> <code>../</code></td>
      <td> the PIA's home directory <code>PIA_HOME</code></td>
  <tr><td> <code>/~/</code></td>
      <td> The PIA's real root directory <code>PIA_ROOT</code></td>
  <tr><td> <code>/</code></td>
      <td> An absolute path in URL format.</td>
  <tr><td> <code>file:</code></td>
      <td> An absolute path in system format.</td>
</table>

<p> When the <code>file:</code> prefix is not present, paths are in ``URL
    format'':  slash characters are converted, if necessary, to the
    operating system's file separator.
</p>


<p> In elements that may access URL's as well as files, for example an
    additional prefix of <code>pia:</code> is used to distinguish between
    normal file lookup, as above, and agent-based lookup, which is the
    default.  In agent-based lookup, extensions and paths are handled
    according to the agent's naming rules, above.  In other words, anything
    that looks like the file part of a URL is treated as if it was:
</p>

<table>
  <tr><td> <code>/<em>path</em>/<em>name</em></code></td>
      <td> looked up relative to the given agent </td>
  <tr><td> <code>&nbsp;</code></td>
      <td> relative paths are looked up by the <em>current</em> agent </td>
  <tr><td> <code>pia:~/</code></td>
      <td> The user's home directory </td>
  <tr><td> <code>pia:./</code></td>
      <td> (or any relative path) the PIA agent directory</td>
  <tr><td> <code>pia:../</code></td>
      <td> the PIA home directory <code>PIA_HOME</code></td>
  <tr><td> <code>pia:/~/</code></td>
      <td> The PIA user directory <code>PIA_ROOT</code></td>
  <tr><td> <code>pia:/</code></td>
      <td> An absolute path in URL format.</td>
  <tr><td> <code>file:</code></td>
      <td> An absolute path in system format.</td>
</table>

<h3>Standard Files</h3>

<p>A PIA Agent consists of little more than a collection of
extended HTML (XHTML) files organized in a directory.
Agents require a set of standard files.
Those files, listed below, are "inherited" from the root directory
(PIA_HOME/Agents) if they are not found in the agent's home directory.</p>

<ul>
<li> <code>home.xh</code><br>
     
     The agent's "home page." This is the page that appears when the agent is
     selected from the Agency's list of running agents. It is therefore
     usually the first page seen by a user, and should include links to at
     least the most useful of the agent's other pages. It is returned from a
     request for <code>/AgentName</code>.</li>

<li> <code>index.xh</code> and <code>about.inc</code><br>
     
     The page returned from a request for <code>/AgentName/</code>. Note
     the trailing slash that distinguishes this page from the home page.
     It gives a standardized listing of the agent's default pages, sub-agents,
     and so on.  Typically, it needs no customization.  The default includes
     the agent-specific file <code>about.inc</code> if it is present.</li>

<li> <code>help.xh</code> and <code>help.inc</code><br>
     
     This page is meant to provide general and context-specific help for the
     agent.  The default page is customized by including the agent-specific
     file <code>help.inc</code>, if present. </li>

<li> <code>options.xh</code><br>
     Lists the agent's options.  This page seldom, if ever, requires
     customization.  The <code>options</code> page also displays the agent's
     data in XML format, suitable for use in an <code>AGENT.xml</code> file.
     </li>

<li> <code>AGENT.xml</code><br>
     This XML file is <em>loaded</em> (read by the PIA) to initialize and
     install the agent.  It contains all the information necessary for
     constructing the agent.  A version of it can be written into the agent's
     user directory to preserve user customizations. </li>

<li> <code>initialize.xh</code><br>
     This XHTML file is invoked automatically when the agent is created. It
     defines default values for any options and sets the "match criteria" for
     transactions that the agent acts on. This file does <em>not</em> have a
     default, but it can be omitted if it is not needed.</li>
</ul>

</blockquote>


<font color="red">
bills' proposal here

<h2><a name="Files"></a>Application Files</h2>

<p>This section describes the files that make up an application.</p>

<h3>File Name Suffixes</h3>

<p> Unlike most web servers, the PIA does not require filename extensions
    (also called ``suffixes'' or, in Windows, ``filetypes'').  This makes it
    possible to refer to a document without revealing to the user whether it
    is an ordinary HTML file or is created on-the-fly from an active document.
    It also makes URL's shorter (and hence easier to remember). 
</p>

<p> Documents in an application's home directory and subdirectories are looked up
    with a different (larger) set of suffixes.  A file's extension, as usual,
    determines its MIME type.  Here are some examples: 
</p>

<table>
  <tr><th> &nbsp; </th>
      <th> tagset </th>
      <th> meaning </th>
  </tr>
  <tr><th> .xh </th> <td> xhtml </td>
      <td> Extended HTML </td>
  </tr>
  <tr><th> .xx </th> <td> xxml </td>
      <td> Extended XML </td>
  </tr>
  <tr><th> .html </th> <td> html </td>
      <td> Ordinary HTML </td>
  </tr>
  <tr><th> .htm </th> <td> html </td>
      <td> Ordinary HTML </td>
  </tr>
  <tr><th> .xml </th> <td> <em>none</em> </td>
      <td> Ordinary XML </td>
  </tr>

  <tr><th colspan=2>&nbsp;</th><th>&nbsp;</th></tr>

  <tr><th colspan=2>&nbsp;</th>
      <th> (used internally) </th>
  </tr>

  <tr><th> .inc </th> <td> xhtml </td>
      <td> ``include'' files </td>
  </tr>
  <tr><th> .ts </th> <td> tagset </td>
      <td> tagset files </td>
  </tr>
  <tr><th> .xml </th> <td> depends on usage. </td>
      <td> Ordinary XML </td>
  </tr>
</table>


<p>But the processor not only needs to know what is in the file, but also what
    rules to apply in processing that file type...so the PIA uses special
    extension-mapping files (like <code>extensions.xci</code>) to tell the
    processor which tagset to use in processing which file.  Usually, these
    mappings are straightforward (like "use the local tagset on all
    <var>.xh</var> files"), but may also be much more flexible and powerful
    (see the <var>Samples/ExtensionDemo</var> application, which assigns the
    local tagset to any file with the <var>.foo</var> suffix). </p>

<h3>File Name Locations</h3>

<p> Where is the "current working directory" for an active page?  If an active
    page tries to read the file <var>../Agents/Foo</var>, where will the
    processor look?  If it tries to write that file, where will it write?
</p>

<p> In fact, reading and writing are somewhat different.  <strong>All</strong>
    file-writing takes place in the <var>PIA_ROOT</var> directory
    (e.g. <var>.pia</var>) or where its configuration files point,
    automatically creating the whole stack of intervening directories if
    necessary.  And the current directory is wherever the calling page
    (e.g. <code>home.xh</code>) lives, as decided by the processor's
    interpretation of the various configuration files (<var>
    _subsite.xcf</var>, as outlined above).  </p>

  <p> File-reading, as mentioned before, tries at first to act like
      file-writing (looking under <var>PIA_ROOT</var> either for the file or
      for a configuration file pointing to it), and uses the same "current
      working directory" as file-writing.  But (unlike in the writing case),
      if the processor fails to find the desired file in that fashion, it
      falls back to looking under <var>PIA_HOME</var>, and searches <i> there
      </i> for the file or for configuration pointers. </p>

  <p><strong> This process can sometimes lead to confusion; be aware that
  files may not be written or read where you first expect. </strong>  The
  least confusing approach is to create and modify all files directly under
  <var>PIA_ROOT</var>; then everything will be read and written in the same
  place, and path names will be transparent. </p>

<h3> File formats </h3>

<p> There are further rules for the format of filenames and URLs, when dealing
    with attributes that designate system resources, like ``<code>src</code>''
    in the &lt;include&gt;, &lt;connect&gt;, and &lt;status&gt; elements, and
    the ``system names'' of entities. 
</p>


<p>?????????  Steve- does initialization still make a difference here? ???</p>

<p> When the <code>file:</code> prefix is not present, paths are in ``URL
    format'':  slash characters are converted, if necessary, to the
    operating system's file separator.  So <var>../MyApp/home.xh</var> will be
    converted (on DOS/Windows) to <var>..\MyApp\home.xh</var>. One the other
    hand,  <var>file:../MyApp/home.xh</var> will not be converted.
</p>


<p> In elements that may access URL's as well as files, for example an
    additional prefix of <code>pia:</code> 
is used to distinguish between normal file lookup, as above, and application-based
    lookup, which is the default.  In application-based lookup, extensions and paths
    are handled according to the application's naming rules, above.  In other words,
    anything that looks like the file part of a URL is treated as if it was:
</p>

<p>?????????  Steve- better check this table... ???</p>

<table>
  <tr><td> <code>pia:~/</code></td>
      <td> The user's home directory </td>
  <tr><td> <code>pia:./</code></td>
      <td> (or any relative path) the current application directory</td>
  <tr><td> <code>pia:../</code></td>
      <td> one level above the current application directory</td>
  <tr><td> <code>pia:/~/</code></td>
      <td> The PIA-user directory <code>PIA_ROOT</code></td>
  <tr><td> <code>pia:/</code></td>
      <td> (same as above)</td>
  <tr><td> <code>file:</code></td>
      <td> An absolute path in system format, relative to / (Unix) or (say) C:\
	   (Windows)</td>
</table>

<h3>Standard Files</h3>

<p>A PIA Application consists of little more than a collection of
extended HTML (XHTML) files organized in a directory.
Applications require a set of standard files.
Those files, listed below, are "inherited" from the root directory
(PIA_HOME/Agents) if they are not found in the application's home directory.</p>

<ul>

<li> <code>index.xh</code> <br>
     
     The page returned from a request for <code>/ApplicationName/</code>. Note
     the trailing slash that distinguishes this page from the home page.
     It gives a standardized listing of the application's default pages, sub-applications,
     and so on.  Typically, it needs no customization. </li>

<li> <code>_subsite.xcf</code><br>
     This XML file sets all the configuration options, such as assigning
     tagsets to files, pointing to directories elsewhere, even determining
     which port the PIA will listen to. </li>

<li> <code>initialize.xh</code><br> This XHTML file is invoked automatically
     when the application is first called. ??????????It defines default values for
     any options and sets the "match criteria" for transactions that the application
     acts on.?????????????? This file does <em>not</em> have a default, but it
     can be omitted if it is not needed.</li>
</ul>
</font>


<blockquote>

================= This section is questionable; is it really necessary? ===

<h2><a name="Code">Agent Data Structures and Code</a></h2>

<p>Every installed agent has an associated software object which
contains its options (stored as entities in the <code>AGENT</code>
namespace) and the criteria that match features of the transactions
in which the agent has registered interest.</p>

<p> This object is normally an instance of the class
    <code>GenericAgent</code>.  If a subclass of this class is defined in the
    package <code>org.risource.pia.agent</code>, and its name matches the
    agent's type (with the first character capitalized, the rest in lowercase,
    and all period (<code>.</code>) and hyphen (<code>-</code>) characters
    converted to underscore (<code>_</code>) characters), it is loaded
    automatically when the agent is installed.</p>

<p>It is sometimes necessary to use a different programming language from Java
for part of an agent. (For example, PERL is good for text manipulation).  The
best technique is to put the external code into a CGI script (with a
<code>.cgi</code> extension).  PERL is a popular choice for a scripting
language because it is nearly as ubiquitous as Java. Be warned, though, that
not all of its libraries or extensions are available on all systems.</p>

<p> An alternative to CGI scripts is the Java native interface, or Java code
    that uses the <code>exec</code> method of the
    <code>java.lang.Runtime</code> class to invoke an operating-system
    command.  These techniques are not likely to be portable.  At one point,
    there was an element &lt;os-command&gt; that did this; it was removed
    partly for security reasons, and partly to encourage portability.  CGI
    scripts in PERL are more likely to be portable.
</p>

</blockquote>


<h2><a name="Tips"></a>Tips on Agent Creation</h2>

<p>PIA applications and active documents  are so new that few conventions
have become established for their use and there is considerable
room for experimentation. A few rules of thumb have become
clear, both for web-page appearance in general and for active-page
style in particular: </p>

<h3>Uniform Look and Feel</h3>

<p>Use tagsets to give a family of related applications a similar appearance. The
PIA uses <code>&lt;header&gt;</code>, <code>&lt;subhead&gt;</code>, and
<code>&lt;footer&gt;</code> in this way; almost every application XHTML page
includes the code which expands into a standardized heading.</p>

<p> Use ``include'' files and application-specific entities to customize inherited
    pages.  The standard <code>include</code> files currently available
    are:
</p>

<ul>
  <li><code>about.inc</code> <br>
       Information "about" an application. This information is similar to what
       you might see on the "about" menu item on a Windows or Macintosh
       application. This is displayed by the default <code>home.xh</code>
       file just underneath the quick reference generated by the
       <code>&lt;subhead&gt;</code> element.</li>

  <li><code>insert.inc</code> <br>
       An image or set of links "inserted" in the normally-empty space to
       the left of the quick reference. On an application, this is often a
       link to the application that serves as a control panel.</li>
</ul>

<p> The other files that are frequently modified are: </p>

<ul>
  <li> <code>home.xh</code><br>
       Almost every application will benefit from a customized home page.
       Application-specific information is often put into the home page's 
       <code>&lt;subhead&gt;</code> element, for example. 

  <li> <code><em>Application</em>-xhtml.ts</code><br>
       An application-specific tagset file.  This allows modified versions of tags
       such as <code>&lt;header&gt;</code> and <code>&lt;subhead&gt;</code> to
       be defined (redefining <code>&lt;subhead&gt;</code> is not uncommon),
       as well as tags that are unique to the application. </li> 
</ul>

<h3>Quick Reference Up Front</h3>

<p>An application's home page is the easiest to access. Additionally,
many users have browsers with small screens. Therefore it makes
sense to put the most-commonly-used functions, and links to the
most-commonly-used pages, as close to the top of an application's home
page as possible.</p>

<p>There are two common formats for this. The first uses a single
column of links near the right-hand side of the screen. The column
just to the left contains a small number of labels.  This format is
automatically generated by the  <code>&lt;subhead&gt;</code> tag; its contents
can contain additional two-column table rows. </p>

<p>The second format is sometimes used on the home pages of applications,
which typically have many functions. It consists of <em>three</em>
columns of icons, or of mixed icons and text.</p>

<h3>No Nasty Surprises</h3>

<p>It is perfectly possible to put a query string into a link, and so have an
ordinary-looking link or icon that is equivalent to submitting a form (our
SimpleCalendar and Tutorial applications both do this).  But be careful,
because forms can carry very general instructions to the PIA server-- some of
our prototype appliances included a form for shutting down the system!</p>

<p>Many users experiment, clicking links at random.   It's a good
idea to make any irreversible actions the result of submitting a form, rather
than just following a link.  This also gives you a chance to ask the user for
confirmation.</p>

<p>You may also want to use a robot to build an index of your PIA, or to
identify broken links.</p>

<blockquote>Eventually it will be possible to use standard HTTP
authentication to keep unauthorized users away from applications or forms
you do not want them to use.</blockquote>

<h3>Active Documentation</h3>

<p>XHTML forms make it easy to mix controls or forms with their
documentation. Thus, it is possible not only to <em>describe</em> a
function such as a link to a useful page or a form, but to provide
the thing itself and invite the reader to try it out on the
spot.</p>

<p>Wherever possible, an application should be self-documenting,
including links to whatever documents a user may need. This
includes tips on customization as well as advice on how to set the
options. A <code>HEADER.html</code> or <code>index.html</code> file
in the application's home directory may be useful, since it can provide
documentation that the user sees while browsing the application's source
code directory <em>before</em> installation. It should include an
installation form, especially if an application has many options.</p>

<h3>Readable Source</h3>

<p>It goes without saying that the output of a XHTML file--the
user's view--should be easily read, understood, and used. But so
should the input--the author's view.</p>

<p>Appropriate indentation makes for easier-to-read code. Indent
the content of elements such as lists and control structures.
Comment the file as appropriate, using one of the two types of comment
available in the PIA:</p>
<ul>

<li><p> The ordinary HTML comment <code>&lt;!-- like this --&gt;</code> is
passed on by the PIA processor to the browser, so it can appear in the
browser's "Page Source" window.  Unfortunately, this kind of comment can
affect the processing of active tags (because it still exists, even if
invisibly, during processing), and can lead to very puzzling errors (for
example, you may be testing whether a list is empty, and finding that it is
not empty because it contains such a comment).</p> </li>

<li><p> The other type of comment is more like a traditional "programming
    comment", and is ideal for describing what happens in an active page.  It
    looks <code>&lt;?-- like this --?&gt;</code>; any such comments are
    removed at the very first PIA processing step, and thus have no side
    effects at all.  We encourage copious use of this style comment to clarify
    your active pages, just as programmers comment their code. </p></li>
</ul>

<p>Keep a to-do list. Document your design decisions, including
things you tried that turned out to be mistakes.</p>

<p>Use source control (the PIA group uses CVS, which is free,
well-supported, and well-suited for projects with multiple
developers).</p>

<p>Remember, an application's XHTML files are read not only by their
author, but by any users who want to customize or extend them. If
the application is complicated, consider writing an ``implementation
details'' document.</p>

<p> The conventional names for documentation files in the PIA are: </p>

<ul>
  <li> <code>to-do.html</code><br>
       ``to-do'' list, usually with the most recent entries at the top.

  <li> <code>done.html</code><br>
       completed items moved from the ``to-do'' list.

  <li> <code>about.html</code><br>
       an ``implementation details'' document, often including design
       decisions and their motivations.
</ul>

<h4><a name="Directory">Directory Structure</a></h4>

<p>Your Information Agency makes use of two paralles directory trees:</p>

<ul>
  <li> <var>PIA_HOME</var> contains the code, documentation, applications and
       other files released by the PIA group.  This directory can be
       overwritten by <code>cvs update </code>, and may be shared by many
       users on a common filesystem (e.g. in <var>/usr/local/</var>).</li>

  <li> <var>PIA_ROOT</var> (typically <tt>~/.pia</tt> on Unix) stores application
       data and customized active documents.  This directory is always the
       <i>first</i> place the PIA processor looks for files; it only checks
       <var>PIA_HOME</var> if it can't find them here.</li>
</ul>

<p>By default, an application <var>MyApp</var> in the directory
<var>AllApps</var> will read and write its data files into <var>
PIA_ROOT/AllApps/MyApp</var> directory. </p>


????????????Steve-- are these corrections  true????????????

<p>When the PIA processor looks for documents for (say) the URL
<nobr><code>PIAhost:8888/MyApps/Foo</code></nobr>, it will first look in
<code><var>PIA_ROOT/MyApps/Foo</var></code>.  If that
search fails, the application then checks <var><code>
PIA_HOME/MyApps/Foo</code></var>. Thus the <var>History</var>
application searches for its files in <kbd>~/.pia/Agents/History</kbd>
and then in <kbd>/usr/local/bin/pia/Agents/History</kbd>.</p>

<p>This makes it easy to customize applications we have prototyped; you simply
put your  newly-improved documents in <code><var>
PIA_ROOT/Agents/AGENT_NAME/FILENAME.xh</var></code>. For example, a customized
form, <tt>foo.xh</tt> for the <var>History</var> application would go in
<tt>~/.pia/Agents/History/foo.xh</tt>, and would not risk being overwritten by
subsequent History-application updates from RiSource.org. </p>


<p>The following section contains tips on creating applications.
Additional ideas and inspiration might come from a close look at
the interforms of applications that ship with the PIA.</p>


<blockquote>

========== this section is questionable ===============

<h4><a name="installing">Installing Agents</a></h4>

<p>In order for the PIA Agency to know about a particular agent and
direct requests to that agent appropriately, that agent must be
installed.  As agents are represented by persistent software
objects, agent installation creates the object that corresponds to
the agent in question.</p>

<p>There are actually two ways to install an agent:  ``<em>loading</em>'' an
XML definition file, and ``<em>creating</em>'' the agent by submitting an HTML
form that specifies its attributes.  Loading is faster, but creating an agent
is an easy way to install a <em>new</em> agent to experiment with or to
extend. </p>

<p>On start-up, the Information Agency looks in the directory
<var>PIA_ROOT</var> and then <var>PIA_HOME</var> for the
<code>/Admin/agent-files.xml</code>, which specifies the XML files that need
to be loaded.  It also looks in <var>PIA_ROOT</var> for
<code>/Admin/START-UP.html</code>, which contains HTML forms to submit in
order to <em>create</em> agents.</p>

<p>When an agent is created, the PIA loads its <tt>initialize.xh</tt>
file, if one exists.  Consider creating such a file for your agent in
<code>initialize.xh</code>. This file typically contains default values for
variables are used by your agent, and may perform additional actions as well.
When an agent is <em>loaded</em>, the PIA runs the ``hook'' contained in its
<code>&amp;initialize;</code> attribute. </p>

<h4>Entities</h4>

<p>Entity variables can be several levels deep. For example, <tt>
&amp;AGENT:employees;</tt> might return the first item in a list of
employees associated with this agent.  Entities in the <code>AGENT:</code>
namespace are shared by all of that agent's documents, and can even be
accessed from <em>other</em> agents.  (The History agent does this with its
toolbar segment, for example.)</p>

<h4>Inheritance</h4>

<p>Standard forms such as <code>options.xh</code>, can be inherited
from the Agents directory. The PIA Agent looks in the <var>
Agents</var> directory if this form is not found in that agent's
subdirectory, <code>/Agents/<var>AGENT_NAME</var></code>.</p>

<h3>Processing Documents Not Specifically Requested</h3>

<p>Agents can process documents moving through the agency even if
they are not specifically directed to that agent. For example, the
History and remoteTools agents process all proxied documents. Each agent
registers a set of <dfn>criteria</dfn> for the documents it is interested in.
Whenever the agency sees a document that matches an agent's
registered criteria, (requests for documents are considered
documents in their own right), that agent is given a chance to
process the document before sending it on to its destination.</p>

</blockquote>


<h3><a name="Debugging"></a>Debugging Tag-Based Applications</h3>

<p>As with any code, application code may not always work correctly the
first time. Here are some techniques for understanding what is
happening within your application.</p>


<ul>
  <li>  Use the &lt;show-errors /> tag, which will produce bright red error
	messages for common problems like missing or misplaced end-tags,
	attempts to read nonexistent files, and so forth. </li>

  <li> Use the &lt;pretty> tag (and/or nested &lt;pretty>&lt;protect> tags) to
       view the document as the processor sees it, and disentangle possible
       confusion in indentation and nesting.  See its<a
         href="http://pia.rsv.ricoh.com/Tutorial/aboutPrettyRepeat.xh">tutorial
         </a>   page for details. </li>

<li>Use the <a
href="http://pia.rsv.ricoh.com/Tutorial/aboutDebugRepeat.xh">debug tag</a> to
print the parse tree.  This shows how the document parser interprets the
document, or document fragment, and sees the relationships between the various
nodes.  </li>


<li>Look at the HTML source that is generated, using <var> View/Document
Source</var> or <var>View/Page Source</var> (via right-clicking) in the
browser menu. This gives a good indication of where the code broke down.  Some
elements, such as &lt;include&gt;, insert comments into the output document
when an error occurs. </li>

  <li>Use the <tt>&amp;urlQuery</tt>; entity to check that the
<em>expected</em> name/value pairs are being posted from one page to another.
For example, <code>&urlQuery;</code> appears in the
<code>home.xh</code> page for the <code>Samples/Form</code> application, so
you can  see something like following after submitting the form: <code>
data=hi+there</code>.  </li>
     
  <li> Look at the PIA server console (where you ran <code>PIA/bin/pia</code>,
       and where you subsequently re-run it whenever you change
       configurations). Sometimes useful  messages appear there. </li>
       
  <li> Use the <nobr><code>&lt;user-message>
       &amp;myValues;&lt;user-message></code></nobr> tag to print out the
       contents of <code>myValues</code> into the command console running the
       PIA; this allows you to view all kinds of intermediate variables
       without having to change the expansion/output properties of the tags or
       active sections you are investigating. </li>

       <li> Run the pia with the <code>-d</code> (debug) option
     (e.g. <code>PIA/bin/pia -d </code>).  This will produce
     voluminous output about what the PIA thinks it's doing.  Adding the
     <code>-v</code> (verbose) flag will produce even more output, tracing the
     progress of the document processing system. </li>
     
</ul>

<p>The extended HTML tags needed to create applications are described in
the <a href="Tagsets/tsdoc/pia-xhtml.html">PIA XHTML
Manual</a>.</p>


<hr><b>Copyright &copy; 1999 Ricoh Silicon Valley</b>
<br>
</body>
</html>

