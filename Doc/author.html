<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>PIA Application Author's Guide</title>
</head>
<body>
<center>
<h1>PIA Application Author's Guide</h1>
</center>

<p> This document provides an overview of  application writing in the
    PIA system. In particular it describes:
</p>


<ul>
  <li><a href="#Quick">Quick Start</a></li>
  <li><a href="#Apps">Applications and Agents</a></li>
  <li><a href="#Site">Web Site Structure</a></li>
  <li><a href="#Files">File Names and Access</a></li>
  <li><a href="#Code">Programming Issues</a></li>
  <li><a href="#Tips">Tips on application creation</a></li>
</ul>

<p> <font color=red> <strong>Warning!</strong>  Parts of this document are
    still out of date.  Most of those parts are indicated in red; particularly
    dubious sections are indented as well.  
</font></p>

<p>Active pages for sample applications are in the <code>PIA/Agents/</code>
and <code>PIA/Samples/</code> directories. Feel free to use these files as a
source of ideas and examples, and as a basis for creating new applications.</p>

<h2><a name="Quick"></a>Quick Start</h2>

<ul>
<li><p>
 Browse to  the subsites in the <code>Samples/</code> directory.  Find one
 upon which you might like to build, and copy that directory and its contents
into the <code>.pia/</code> (or <code>$PIA_ROOT/</code>) directory, under a
new name (e.g. <code>cp -r ~/PIA/Samples/HelloWorld/ ~/.pia/MyApps/MyFirstPage
</code> ).  Now any changes you make will not be confused with files in the
original source-tree, nor overwritten upon updating via CVS.  And any files
your active pages write or read will appear in (or relative to) this new
directory.</p> </li>

<li><p> In this new directory, change every occurrence of the original name
(<code>HelloWorld</code>) to the new one (<code>MyFirstPage</code>), both
filenames and file content. This ensures that you don't have any stray
references to the original application, and that any proper configurations and
tagsets are used.
</p></li>

          
<li><p> Add some text to the copied <code>home.xh</code> file, and aim your
    browser at the new page
    (e.g.<code> http://myHost:8888/MyApps/MyFirstPage/home.xh </code>)... you
    should see the text.  
</p></li>

<li><p> Define a new tag at the very top of <code>home.xh</code> (as happens
   at the top of <code>HelloWorld/home.xh</code>), and use the tag in the
   body.  Refresh the broswer page (<code>shift-Reload</code>) to see the
   effects.  If you expect to create many such tags, or to use them in other
   pages, you should move them into a tagset file (see--or copy!-- the
   <code>TagsetDemo/</code> sample to see how). </p></li>

<li><p> Add a <code>&lt;show-errors /&gt;</code> tag to your page to indicate
     any errors which may occur.  Try the <code>&lt;pretty /&gt;</code> tag to
     see the structure of your XML.  Check out the <a
     href="http://pia.rsv.ricoh.com/Tutorial/home.xh"> hackable tutorials </a>
     for more explanation of how such tags work. Play around!</p></li>

</ul>


<h2><a name="Apps">Applications and Agents</a></h2>

<p> PIA stands for ``Platform for Information Applications,'' so we need to
    start by explaining exactly what an application <em>is</em> and how the
    user can access it.  The short answer is that an application is <em>any
    location in the PIA's web site that performs a service for the user by
    means of active documents.</em>
</p>

<p> The first time the user visits an application's location, its local
    configuration file, <code>_subsite.xcf</code>, is loaded (if it exists),
    which gives the application a chance to perform any necessary setup.  This
    includes making the application's ``home directory'' available at the top
    of the PIA's URL space as <code>/~<em>AppName</em></code>.
</p>

<p> It is possible to pre-load applications by accessing them in the PIA's
    top-level initialization file, <code>/initialize.xh</code>.
</p>

<h3><a name="Agents">Agents</a></h3>

<p> There are roughly two kinds of applications: passive and active.  Passive
    applications "just sit there," doing nothing until a request for a page
    comes in... at which point the processor finds the right page, processes
    the appropriate <var>.xh</var> file, and sends back the processed
    results. This is like a traditional static web-page or CGI script.
</p>

<p> Active applications, on the other hand, are more like "software agents" in
    the traditional sense: they are background processes, always on, which
    eavesdrop on and potentially modify all the port's traffic.  For example,
    the <var>History</var> application (under <var>/Agents/</var>) keeps track
    of every URL visited, and the <var>remoteTools</var> application modifies
    incoming HTML according to the user's customization rules.  This is like a
    traditional proxy-server.
</p>

<p> Strictly speaking, an Agent is a piece of (usually XML) code that is run
    in response to some internal event, rather than in response to a direct
    request for a document.  At the moment, agents can respond to either a web
    transaction (request or response) that matches some ``criteria'', or can
    be run at a particular time or repetition interval.
</p>

<p> It's difficult to draw a clear distinction between agents and
    applications; any application may potentially start an arbitrary number of
    agents.  In fact, an agent can exist purely to register an application's
    home directory.
</p>

<blockquote>
    <p> Some history here:  originally, <em>all</em> applications in the PIA
	were associated with agents, and all of their ``home directories''
	were accessible at the top level.  This persists in the terminology:
	we still tend to use ``Agent'' and ``Application'' interchangeably,
	and in fact the line between them is rather fuzzy -- there's no way
	for a casual user to determine whether or not an application contains
	an Agent.
    </p>
</blockquote>

<p> The prototype applications in <var>Samples/</var> are of the passive
    type; it is best to get accustomed to using these before tinkering with
    the more subtle and complex active ones.  Once you are ready, look at
    <var>/Agents/Proxie/History</var> as a prototype active application.
</p>

<h3>Naming Conventions</h3>

<p> By convention, most application names are capitalized, but this is not
    required. Name lookup is case-sensitive, and there may be good reasons to
    prefer uppercase or lowercase names in some cases.  For example,
    <code>fileTools</code> and <code>remoteTools</code> are really
    ``sub-applications'' of <code>Toolbar</code>, and so have lowercase names.
</p>

<p> It is also conventionally true that the ``home directory'' of an
    application (i.e. the name starting with <code>/~</code>) has the same
    name as the application's own home directory, but this is <em>also</em>
    not universally true.  For example, <code>/~Calendar</code> refers to the
    application directory <code>/Agents/SimpleCalendar</code> -- the shortened
    form is more generic, and makes it easy to replace
    <code>SimpleCalendar</code> with something more complex without breaking
    any links.
</p>


<h2><a name="Structure"></a>Web Site Structure</h2>

<h3>Resources and Locations</h3>

<p> When a PIA is running and in use it functions as a web server, so that it
    looks to the user like a web site.  The user's view of the PIA is as a a
    collection of documents, each with its own URL.  URL stands for
    <em>Uniform Resource Locator</em>, so the technical term for something
    ``addressed'' by a URL is a <em>Resource</em>.  The PIA follows this
    terminology.
</p>

<p> URL's form a branching structure called the ``<em>URL tree</em>'' (when
    its structure is being emphasized) or ``<em>URL space</em>'' (to emphasize
    the space-like uniformity of URL's).  This structure is at least partially
    hidden from the user by the browser, which lets the user jump around at
    random by clicking on links.  Only if the user glances at the browser's
    ``location'' text box does the hierarchical nature of URL space become
    apparent. 
</p>

<p> The terminology for a resource that behaves like a directory, with other
    resources contained inside it, is not particularly well-established.  Many
    people use ``<em>Container</em>,'' but ``<em>Location</em>'' is also
    popular.  The PIA actually uses both terms with slightly different
    meanings: a ``location'' is a position in the URL tree, while a
    ``container'' is the resource <em>located at</em> that position.  Location
    is effectively a synonym for URL, while a directory in the filesystem is
    a kind of container.
</p>

<p> A resource that is not a container is called a ``<em>document</em>.''  A
    document has both a location in the URL tree, and a container in the
    resource tree.  Every container has an associated document that is shown
    when the container's URL is requested.  By default this is a generic
    listing of the container's contents; the default is usually overridden by
    providing a ``home document'' (called <code>index.html</code> in most web
    servers).  The PIA usually uses the name <code>home.xh</code> for this
    document.
</p>

<p> To make matters slightly more complicated, a PIA's web site is
    <em>also</em> called a ``<em>Site</em>'', and each container resource
    within it is called a ``<em>Subsite</em>.''  These terms refer to the
    PIA's <em>particular implementation</em> of resources, in which several
    directories (in the filesystem sense) may be overlaid to form a single
    container.  (This is explained in the next subsection.)  
</p>

<p> The distinctions here are totally invisible to the user, who sends the PIA
    a URL (resource locator) and gets a document back in response.  They are,
    however, important to the application author, and even more important to
    the programmer.  The application author needs to know about subsites in
    order to understand the otherwise inexplicable name
    (<code>_subsite.xcf</code>) of the PIA's configuration files.  The
    programmer will quickly discover that <code>Resource</code> is the name of
    an <em>interface</em>, while <code>Subsite</code> is the name of one of
    its <em>implementations</em>, in a language (Java) in which interfaces and
    implementations have to have different names.
</p>


<h3>Files and Directories</h3>

<font color="red">
 This section needs a little work.
</font>

<p> Where is the "current working directory" for an active page?  If an active
    page tries to read the file <var>../Agents/Foo</var>, where will the
    processor look?  If it tries to write that file, where will it write?
</p>

<p> Every application (or "subsite") lives in a directory. In the simplest
    case, the directory has the same name as the application and is located
    under <var>PIA_ROOT/</var>.  For instance, the example in the Quick-start
    section above creates the <code>MyFirstPage</code> application in the
    directory <var>.pia/MyApps/MyFirstPage</var>.  Also, the applications we
    provide are in same-named directories under <var>PIA/Agents</var> and
    <var>PIA/Samples</var>. Various configuration files
    (<var>_subsite.xcf</var>) could tell the processor to look for the
    application in other directories instead.
</p>

<p> But in all cases, the application's URL always <i>looks</i> as if the
    application resides directly under the URL's root (the "slash" after the
    port number). So, for example, the <code>MyFirstPage</code> URL would be
    <var>http://piaHOST:8888/MyApps/MyFirstPage</var>, and the
    <code>HelloWorld</code> URL would be
    <var>http://piaHOST:8888/Samples/HelloWorld</var>, with no indication that
    one lives under <var>.pia/</var> and the other under <var>PIA/</var>.
</p>

<p> The procesor has internal rules for deciding where to look for files
    belonging to given a URL (in this example, the rule is "look in
    <var>.pia/</var> before looking in <var>PIA/</var>").  But you can add
    more rules via the configuration files, so that an application's active
    pages, tagsets, subdirectories and so forth can reside <i>anywhere</i>;
    you just need to make sure that a (real) <var>_subsite.xcf</var> file
    under <var>PIA_ROOT</var> or <var>PIA_HOME</var> tells the processor where
    the "anywhere" is.
</p>


<p> Even the base directories <var>PIA_HOME</var> and <var>PIA_ROOT</var> can
    be set on the <code>pia</code> command line or in the corresponding
    environment variables.  They are normally the root of the PIA directory
    tree (called PIA and located wherever the PIA is installed in your system)
    and  a directory called <code>.pia</code> in your home directory.
</p>


<p> In fact, reading and writing are somewhat different.  <strong>All</strong>
    file-writing takes place in the <var>PIA_ROOT</var> directory
    (e.g. <var>.pia</var>) or where its configuration files point,
    automatically creating the whole stack of intervening directories if
    necessary.  And the current directory is wherever the calling page
    (e.g. <code>home.xh</code>) lives, as decided by the processor's
    interpretation of the various configuration files (<var>
    _subsite.xcf</var>, as outlined above).  </p>

<p> File-reading, as mentioned before, tries at first to act like
    file-writing (looking under <var>PIA_ROOT</var> either for the file or
    for a configuration file pointing to it), and uses the same "current
    working directory" as file-writing.  But (unlike in the writing case),
    if the processor fails to find the desired file in that fashion, it
    falls back to looking under <var>PIA_HOME</var>, and searches <i> there
    </i> for the file or for configuration pointers. </p>

<p> <strong> This process can sometimes lead to confusion; be aware that
    files may not be written or read where you first expect. </strong>  The
    least confusing approach is to create and modify all files directly under
    <var>PIA_ROOT</var>; then everything will be read and written in the same
    place, and path names will be transparent. </p>



<h2><a name="Files"></a>File Names and Access</h2>

<p> This section describes the conventions for naming files, and for
    specifying files inside of active tags.
</p>

<h3>Filename Extensions</h3>

<p> Unlike most web servers, the PIA does not require filename extensions
    (also called ``suffixes'' or, in Windows, ``filetypes'').  This makes it
    possible to refer to a document without revealing to the user whether it
    is an ordinary HTML file or is created on-the-fly from an active document.
    It also makes URL's shorter (and hence easier to remember). 
</p>

<p> Documents in application directories may be looked up with
    a different (larger) set of suffixes from files in a data directory;
    this reflects the fact that active documents are not permitted in the data
    directory, for security reasons.
</p>

<p> A file's extension, as usual, determines its MIME type -- the information
    the browser needs in order to display the file correctly.  But because the
    PIA processes active documents at the server level, it not only needs to
    know what is in the file, but also what rules (contained in a so-called
    ``tagset'' file) to apply in processing that
    file type.

<p> The mapping from extensions to MIME types and tagsets is usually specified
    in a file called <code>extensions.xci</code>; however the default mapping
    can be overridden or extended by any application for its own purposes
    (see the <var>Samples/ExtensionDemo</var> application, which assigns the
    local tagset to any file with the <var>.foo</var> suffix).
</p>

<table align="center"  width="90%" border="2" cellpadding="4">
  <tr><th> Ext. </th>
      <th align="left"> MIME type </th>
      <th align="left"> tagset </th>
      <th align="left"> meaning </th>
  </tr>
  <tr><th> .xh </th> <td> text/html </td> <td> xhtml </td>
      <td> Extended HTML </td>
  </tr>
  <tr><th> .xx </th> <td> text/xml </td> <td> xxml </td>
      <td> Extended XML </td>
  </tr>
  <tr><th> .html </th> <td> text/html </td> <td> HTML </td>
      <td> Ordinary HTML </td>
  </tr>
  <tr><th> .htm </th> <td> text/html </td> <td> HTML </td>
      <td> Ordinary HTML </td>
  </tr>
  <tr><th> .xml </th> <td> text/xml </td> <td> <em>none</em> </td>
      <td> Ordinary XML </td>

  <tr><th colspan=4>&nbsp;</th></tr>

  <tr><th colspan=4>&nbsp; (used internally) </th>
  </tr>

  <tr><th> .xcf </th> <td> <em>hidden</em> </td> <td> pia-config </td>
      <td> XML Configuration File </td>
  </tr>
  <tr><th> .xci </th> <td> <em>hidden</em> </td> <td> pia-config </td>
      <td> included in a <code>.xcf</code> file. </td>
  </tr>
  <tr><th> .inc </th> <td> <em>hidden</em> </td> <td> <em>current</em> </td>
      <td> ``include'' files </td>
  </tr>
  <tr><th> .ts </th> <td> <em>hidden</em> </td> <td> tagset </td>
      <td> tagset files </td>
  </tr>
  <tr><th> .xml </th> <td> <em>hidden</em> </td>
      <td> <em>various</em> </td>
      <td> Ordinary XML </td>
  </tr>
</table>



<h3>Configuration Files</h3>

<p> The PIA uses a fairly small number of standard files to determine its
    configuration.
</p>

<table align="center" width="90%" border="2" cellpadding="4">
  <tr><th> File
      </th>
      <th> Location
      </th>
      <th> Usage
      </th>
  </tr>
  <tr><td align="top"> <code><em>user-specified</em>.xcf</code>
      </td>
      <td> command line
      </td>
      <td> top-level configuration file.   This overrides any
	   <code>_subsite.xcf</code> file in the top-level directory.
      </td>
  </tr>
  <tr><td align="top"> <code>initialize.xh</code>
      </td>
      <td> top level
      </td>
      <td> PIA initialization.
      </td>
  </tr>
  <tr><td align="top"> <code>_subsite.xcf</code>
      </td>
      <td> any directory
      </td>
      <td> per-directory configuration information and metadata.
      </td>
  </tr>
  <tr><td align="top"> <code><em>appname</em>-xhtml.ts</code>
      </td>
      <td> any application
      </td>
      <td> conventional name for an application's local tagset file.
      </td>
  </tr>
</table>


<h3>Application Files</h3>

<p> A PIA application consists of little more than a collection of
    extended HTML (XHTML) files organized in a directory.  Some of these files
    have conventional names, to make it easier for a user to navigate the
    resource tree.
</p>


<table align="center"  width="90%" border="2" cellpadding="4">
  <tr><td align="top"> <code>home.xh</code>
      </td>
      <td> required
      </td>
      <td> The ``home page'' for the application.  This is usually the first
	   page seen by a user of the application, so it should include links
	   to at least the most commonly used other pages. 
      </td>
  </tr>
  <tr><td align="top"> <code>DATA/</code>
      </td>
      <td> recommended
      </td>
      <td> The conventional name for the sub-directory where the application
	   stores its data.  You can, however, use any name you like. 
      </td>
  </tr>
  <tr><td align="top"> <code>help.xh</code>
      </td>
      <td> optional
      </td>
      <td> Where the user looks for help.  It is possible to configure a
	   virtual link to a default version of <code>help.xh</code>.
      </td>
  </tr>
  <tr><td align="top"> <code>about.html</code>
      </td>
      <td> optional
      </td>
      <td> A good name for a file that gives background information on the
	   application:  its goals, philosophy, and so on.  Often includes
	   documentation of major design decisions.
      </td>
  </tr>
  <tr><td align="top"> <code>to-do.html</code>
      </td> 
      <td> optional
      </td>
      <td> Application-maintainer's ``to-do'' list. 
      </td>
  </tr>
  <tr><td align="top"> <code>done.html</code>
      </td>
      <td> optional
      </td>
      <td> Items moved from the ``to-do'' list after being completed.
      </td>
  </tr>

  <tr><th colspan=3>&nbsp;</th></tr><!-- include files -->
  <tr><th colspan=3>Include files</th></tr>
  <tr><td align="top"> <code>HEADER.html</code>
      </td>
      <td> recommended
      </td>
      <td> Appears at the top of a directory listing. 
      </td>
  </tr>
  <tr><td align="top"> <code>about.inc</code>
      </td>
      <td> optional
      </td>
      <td> often included by <code>home.xh</code>, especially if an
	   application has multiple entry points. 
      </td>
  </tr>
  <tr><td align="top"> <code>help.inc</code>
      </td>
      <td> optional
      </td>
      <td> included by the default version of <code>help.xh</code>.
      </td>
  </tr>
</table>


<h3>File Access</h3>

<p> Locations passed to the PIA in URL's are always looked up in the site
    resource tree.  Relative filenames always have the current base (pathname)
    prepended by the browser.
</p>

<p> Inside the PIA things are somewhat more complex:  an application may need
    to refer to things elsewhere in the file system, including files that
    aren't part of the PIA's resource tree at all.  In particular, this
    happens in the  attributes that designate system resources:
    ``<code>src</code>'' in the &lt;include&gt;, &lt;connect&gt;, and
    &lt;status&gt; elements, ``<code>file</code>'' and
    ``<code>virtual</code>'' attributes in subsite configuration files, and
    the ``system names'' of entities.  The following conventions are used:
</p>

<ol>
  <li> Locations without a ``protocol'' prefix (e.g. ``<code>file:</code>'')
       are treated as URL's, exactly the way the browser would treat them.  In
       other words, they refer to exactly the same resources that would be
       returned to the user if that URL was requested.  Locations without a
       leading ``<code>/</code>'' (slash) character are looked up relative to
       the location of the referring document.

  <li> The prefixes given in the following table are used to specify locations
       outside of URL space:

       <font color="red">
       <p>
       <strong>=== THIS TABLE IS A TOTAL LIE!===</strong><br>
       ... but it represents the way I <em>intend</em> to make it work.
       </font>

       <table>
           <tr><td valign="top"> <code>file:</code></td>
               <td> A file, using normal filesystem conventions.  Relative
		    paths are relative to the directory in which the
		    <code>pia</code> command was given.  
               </td>
           <tr><td> <code>path:</code></td>
               <td> A file with its path specified in ``<em>URL
		    format</em>'', with forward slashes.  Paths starting with
		    <code>~/</code> are relative to the user's home directory.
               </td>
           <tr><td> <code>pia:</code></td>
               <td> A path, in <em>URL</em> format (with forward slashes),
		    relative to the PIA's ``home'' directory
		    <code>$PIA_HOME</code>
               </td> 
           <tr><td> <code>real:</code></td>
               <td> A path, in <em>URL</em> format, relative to the ``real
		    root'' directory <code>$PIA_ROOT</code>.
               </td>
           <tr><td> <code>virtual:</code></td>
               <td> A path, in <em>URL</em> format, relative to the ``virtual
		    root'' directory if there is one.
               </td>
       </table>

  <li> Files passed on the <code>pia</code> command line or in environment
       variables are in system format, i.e. treated as if they had an implicit
       ``<code>file:</code>'' prefix.
</ol>

<p> When the <code>file:</code> prefix is not present, paths are in ``URL
    format'':  slash characters are converted, if necessary, to the
    operating system's file separator.  So <var>../MyApp/home.xh</var> will be
    converted (on DOS/Windows) to <var>..\MyApp\home.xh</var>.
</p>


<h2><a name="Code">Programming issues</a></h2>

<blockquote>
<p><em>non-programmers can safely skip this section.</em>
</p>
</blockquote>

<p>Every installed agent has an associated software object which
contains its options (stored as entities in the <code>AGENT</code>
namespace) and the criteria that match features of the transactions
in which the agent has registered interest.</p>

<p> This object is normally an instance of the class
    <code>GenericAgent</code>.  If a subclass of this class is defined in the
    package <code>org.risource.pia.agent</code>, and its name matches the
    agent's type (with the first character capitalized, the rest in lowercase,
    and all period (<code>.</code>) and hyphen (<code>-</code>) characters
    converted to underscore (<code>_</code>) characters), it is loaded
    automatically when the agent is installed.</p>

<p> It is sometimes necessary to use a different programming language from
    Java for part of an application. (For example, PERL is good for text
    manipulation).  The best technique is to put the external code into a CGI
    script (with a <code>.cgi</code> extension).  PERL is a popular choice for
    a scripting language because it is nearly as ubiquitous as Java. Be
    warned, though, that not all of its libraries or extensions are available
    on all systems.
</p>

<p> An alternative to CGI scripts is the Java native interface, or Java code
    that uses the <code>exec</code> method of the
    <code>java.lang.Runtime</code> class to invoke an operating-system
    command.  These techniques are not likely to be portable.  At one point,
    there was an element &lt;os-command&gt; that did this; it was removed
    partly for security reasons, and partly to encourage portability.  CGI
    scripts in PERL are more likely to be portable.
</p>


<h2><a name="Tips"></a>Tips on Application Writing</h2>

<p>PIA applications and active documents  are so new that few conventions
have become established for their use and there is considerable
room for experimentation. A few rules of thumb have become
clear, both for web-page appearance in general and for active-page
style in particular: </p>

<h3>Uniform Look and Feel</h3>

<p> Use tagsets to give a family of related applications a similar
    appearance. The PIA uses <code>&lt;header&gt;</code>,
    <code>&lt;subhead&gt;</code>, and <code>&lt;footer&gt;</code> in this way;
    almost every application XHTML page includes the code which expands into a
    standardized heading.
</p>

<p> Use ``include'' files and application-specific entities to customize
    inherited pages.  The standard <code>include</code> files currently
    available are:
</p>

<ul>
  <li><code>about.inc</code> <br>
       Information "about" an application. This information is similar to what
       you might see on the "about" menu item on a Windows or Macintosh
       application. This is displayed by the default <code>home.xh</code>
       file just underneath the quick reference generated by the
       <code>&lt;subhead&gt;</code> element.</li>

  <li><code>insert.inc</code> <br>
       An image or set of links "inserted" in the normally-empty space to
       the left of the quick reference. On an application, this is often a
       link to the application that serves as a control panel.</li>
</ul>

<p> The other files that are frequently modified are: </p>

<ul>
  <li> <code>home.xh</code><br>
       Almost every application will benefit from a customized home page.
       Application-specific information is often put into the home page's 
       <code>&lt;subhead&gt;</code> element, for example. 

  <li> <code><em>Application</em>-xhtml.ts</code><br>
       An application-specific tagset file.  This allows modified versions of tags
       such as <code>&lt;header&gt;</code> and <code>&lt;subhead&gt;</code> to
       be defined (redefining <code>&lt;subhead&gt;</code> is not uncommon),
       as well as tags that are unique to the application. </li> 
</ul>

<h3>Quick Reference Up Front</h3>

<p>An application's home page is the easiest to access. Additionally,
many users have browsers with small screens. Therefore it makes
sense to put the most-commonly-used functions, and links to the
most-commonly-used pages, as close to the top of an application's home
page as possible.</p>

<p>There are two common formats for this. The first uses a single
column of links near the right-hand side of the screen. The column
just to the left contains a small number of labels.  This format is
automatically generated by the  <code>&lt;subhead&gt;</code> tag; its contents
can contain additional two-column table rows. </p>

<p>The second format is sometimes used on the home pages of applications,
which typically have many functions. It consists of <em>three</em>
columns of icons, or of mixed icons and text.</p>

<h3>No Nasty Surprises</h3>

<p>It is perfectly possible to put a query string into a link, and so have an
ordinary-looking link or icon that is equivalent to submitting a form (our
SimpleCalendar and Tutorial applications both do this).  But be careful,
because forms can carry very general instructions to the PIA server-- some of
our prototype appliances included a form for shutting down the system!</p>

<p>Many users experiment, clicking links at random.   It's a good
idea to make any irreversible actions the result of submitting a form, rather
than just following a link.  This also gives you a chance to ask the user for
confirmation.</p>

<p>You may also want to use a robot to build an index of your PIA, or to
identify broken links.</p>

<blockquote>Eventually it will be possible to use standard HTTP
authentication to keep unauthorized users away from applications or forms
you do not want them to use.</blockquote>

<h3>Active Documentation</h3>

<p>XHTML forms make it easy to mix controls or forms with their
documentation. Thus, it is possible not only to <em>describe</em> a
function such as a link to a useful page or a form, but to provide
the thing itself and invite the reader to try it out on the
spot.</p>

<p>Wherever possible, an application should be self-documenting,
including links to whatever documents a user may need. This
includes tips on customization as well as advice on how to set the
options. A <code>HEADER.html</code> or <code>index.html</code> file
in the application's home directory may be useful, since it can provide
documentation that the user sees while browsing the application's source
code directory <em>before</em> installation. It should include an
installation form, especially if an application has many options.</p>

<h3>Readable Source</h3>

<p> It goes without saying that the output of a XHTML file--the user's
    view--should be easily read, understood, and used. But so should the
    input--the author's view.  This is especially important in an open-source
    system like the PIA; you are almost guaranteed that somebody else will be
    reading your code at some point -- and it's likely that you will be
    reading theirs!
</p>

<p>Appropriate indentation makes for easier-to-read code. Indent
the content of elements such as lists and control structures.
Comment the file as appropriate, using one of the two types of comment
available in the PIA:</p>

<ul>
  <li><p> The ordinary HTML comment <code>&lt;!-- like this --&gt;</code> is
       passed on by the PIA processor to the browser, so it can appear in the
       browser's "Page Source" window.  Unfortunately, this kind of comment
       can affect the processing of active tags (because it still exists, even
       if invisibly, during processing), and can lead to very puzzling errors
       (for example, you may be testing whether a list is empty, and finding
       that it is not empty because it contains such a comment).</p> </li>

  <li><p> The other type of comment is more like a traditional "programming
       comment", and is ideal for describing what happens in an active page.
       It looks <code>&lt;?-- like this --?&gt;</code>; any such comments are
       removed at the very first PIA processing step, and thus have no side
       effects at all.  We encourage copious use of this style comment to
       clarify your active pages, just as programmers comment their
       code. </p>

       <p>It is important to note that <em>there must be a space after the
       ``<code>?--</code>''!</em> Otherwise the first word of the comment will
       be taken as part of the name of an XML processing instruction, which
       will <em>not</em> be recognized as a comment and will be passed on to
       the browser, which in turn will display it to the user, usually in a
       particularly ugly format.  </p>
       </li>
</ul>

<h3>Keep maintainers informed</h3>

<p>Keep a to-do list. Document your design decisions, including
things you tried that turned out to be mistakes.</p>

<p>Use source control (the PIA group uses CVS, which is free,
well-supported, and well-suited for projects with multiple
developers).</p>

<p>Remember, an application's XHTML files are read not only by their
author, but by any users who want to customize or extend them. If
the application is complicated, consider writing an ``implementation
details'' document.</p>

<p> The conventional names for documentation files in the PIA are: </p>

<ul>
  <li> <code>to-do.html</code><br>
       ``to-do'' list, usually with the most recent entries at the top.

  <li> <code>done.html</code><br>
       completed items moved from the ``to-do'' list.

  <li> <code>about.html</code><br>
       an ``implementation details'' document, often including design
       decisions and their motivations.
</ul>

<blockquote>

<font color=red>
========== this section is questionable ===============
</font>

<h4><a name="Directory">Directory Structure</a></h4>


????????????Steve-- are these corrections  true????????????

<p>Your Information Agency makes use of two parallel directory trees:</p>

<ul>
  <li> <var>PIA_HOME</var> contains the code, documentation, applications and
       other files released by the PIA group.  This directory can be
       overwritten by <code>cvs update </code>, and may be shared by many
       users on a common filesystem (e.g. in <var>/usr/local/</var>).</li>

  <li> <var>PIA_ROOT</var> (typically <tt>~/.pia</tt> on Unix) stores
       application data and customized active documents.  This directory is
       always the <i>first</i> place the PIA processor looks for files; it
       only checks <var>PIA_HOME</var> if it can't find them here.</li>
</ul>

<p>By default, an application <var>MyApp</var> in the directory
<var>AllApps</var> will read and write its data files into <var>
PIA_ROOT/AllApps/MyApp</var> directory. </p>

<p>When the PIA processor looks for documents for (say) the URL
<nobr><code>PIAhost:8888/MyApps/Foo</code></nobr>, it will first look in
<code><var>PIA_ROOT/MyApps/Foo</var></code>.  If that
search fails, the application then checks <var><code>
PIA_HOME/MyApps/Foo</code></var>. Thus the <var>History</var>
application searches for its files in <kbd>~/.pia/Agents/History</kbd>
and then in <kbd>/usr/local/bin/pia/Agents/History</kbd>.</p>

<p>This makes it easy to customize applications we have prototyped; you simply
put your  newly-improved documents in <code><var>
PIA_ROOT/Agents/AGENT_NAME/FILENAME.xh</var></code>. For example, a customized
form, <tt>foo.xh</tt> for the <var>History</var> application would go in
<tt>~/.pia/Agents/History/foo.xh</tt>, and would not risk being overwritten by
subsequent History-application updates from RiSource.org. </p>

<h4>Entities</h4>

<p>Entity variables can be several levels deep. For example, <tt>
&amp;AGENT:employees;</tt> might return the first item in a list of
employees associated with this agent.  Entities in the <code>AGENT:</code>
namespace are shared by all of that agent's documents, and can even be
accessed from <em>other</em> agents.  (The History agent does this with its
toolbar segment, for example.)</p>

<h3>Processing Documents Not Specifically Requested</h3>

<p>Agents can be used to process documents moving through the agency. For
example, the History and remoteTools agents process all proxied
documents. Each agent registers a set of <dfn>criteria</dfn> for the documents
it is interested in.  Whenever the agency sees a document that matches an
agent's registered criteria, (requests for documents are considered documents
in their own right), that agent is given a chance to process the document
before sending it on to its destination.</p>

</blockquote>


<h3><a name="Debugging"></a>Debugging PIA Applications</h3>

<p> As with any software, a PIA-based application is unlikely to work
    correctly the first time.  Here are some techniques for understanding what
    is happening within your application.
</p>


<ul>
  <li>  Use the &lt;show-errors /> tag, which will produce bright red error
	messages for common problems like missing or misplaced end-tags,
	attempts to read nonexistent files, and so forth. </li>

  <li> Use the &lt;pretty> tag (and/or nested &lt;pretty>&lt;protect> tags) to
       view the document as the processor sees it, and disentangle possible
       confusion in indentation and nesting.  See its <a
       href="http://pia.rsv.ricoh.com/Tutorial/aboutPrettyRepeat.xh">tutorial
       </a>  page for details. </li>

  <li> Use the <a
       href="http://pia.rsv.ricoh.com/Tutorial/aboutDebugRepeat.xh">debug
       tag</a> to print the parse tree.  This shows how the document parser
       interprets the document, or document fragment, and sees the
       relationships between the various nodes.  </li>


  <li> Look at the HTML source that is generated, using <var> View/Document
       Source</var> or <var>View/Page Source</var> (via right-clicking) in the
       browser menu. This gives a good indication of where the code broke
       down.  Some elements, such as &lt;include&gt;, insert comments into the
       output document when an error occurs. </li>

  <li> Use the <tt>&amp;urlQuery</tt>; entity to check that the
       <em>expected</em> name/value pairs are being posted from one page to
       another.  For example, <code>&urlQuery;</code> appears in the
       <code>home.xh</code> page for the <code>Samples/Form</code>
       application, so you can see something like following after submitting
       the form: <code> data=hi+there</code>.  </li>
     
  <li> Look at the PIA server console (where you ran <code>PIA/bin/pia</code>,
       and where you subsequently re-run it whenever you change
       configurations). Sometimes useful  messages appear there. </li>
       
  <li> Use the <nobr><code>&lt;user-message>
       &amp;myValues;&lt;user-message></code></nobr> tag to print out the
       contents of <code>myValues</code> into the command console running the
       PIA; this allows you to view all kinds of intermediate variables
       without having to change the expansion/output properties of the tags or
       active sections you are investigating. </li>

  <li> Run the pia with the <code>-d</code> (debug) option
       (e.g. <code>PIA/bin/pia -d </code>).  This will produce voluminous
       output about what the PIA thinks it's doing.  Adding the
       <code>-v</code> (verbose) flag will produce even more output, tracing
       the progress of the document processing system. </li>
</ul>

<p>The extended HTML tags needed to create applications are described in
the <a href="Tagsets/tsdoc/pia-xhtml.html">PIA XHTML
Manual</a>.</p>


<hr>
<b>Copyright &copy; 1999 <a href="http://rsv.ricoh.com/">Ricoh Silicon
   Valley</a>.</b> 
   Open Source at &lt;<b><a href="http://RiSource.org/">RiSource.org</a>/<a
                         href="http://RiSource.org/PIA">PIA</a></b>&gt;.<br>
<i>$Id: author.html,v 1.17 1999-10-15 23:13:01 steve Exp $</i><br>
</body>
</html>

