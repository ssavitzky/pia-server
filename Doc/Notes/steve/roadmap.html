<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>Roadmap</title>
</head><body>
<h1>Roadmap</h1>

<blockquote>
  This document describes, at a very high level, where I think the PIA ought
  to be going over the next few months.  
</blockquote>

<dl>
  <dt> <b>See also:</b> <a href="projects.html">projects.html</a>
  <dd> Goes into considerable depth (including design details) on some of the
       projects mentioned here.  
  <dt> <b>See also:</b> <a href="Design/">Design/</a> (subdirectory)
  <dd>  Contains detailed architectural and design notes on individual
	projects.  
</dl>

<h2><a name="Interfaces">PIA, DPS and Standard Interfaces</a></h2>

<h3>DPS:  DOM and SAX</h3>

<p> I see the transition of the DPS to standard interfaces (DOM and SAX) as
    proceeding in these stages:

<ol>
  <li> The Input and Output implementations <code>FromDocument</code>,
       <code>ToDocument</code>, <code>ToSAX</code>.
       (Document, of course, refers to the corresponding DOM class).
       <code>ToDocument</code> already exists as a stub.  <code>FromSAX</code>
       would require the use of two threads and a queue; it's not particularly
       useful because the SAX interface doesn't pass entities to the
       application.  
  <li> Extend Tagset to implement DocumentType (it's almost there now).  This
       would probably be sufficient to allow our own DOM to be used in some
       other applications.  (Not all -- in particular,
       <code>getElementsByTagName</code> is still unimplemented.)  Replace all
       operations that create Nodes by calls on a Document's creation
       methods.  
  <li> Extend the Cursor implementation so that it doesn't require the
       presence of an actual ActiveNode.  (A previous implementation involved
       a DOM Node, but you shouldn't need that, either.)  It may even be
       reasonable to virtualize Text nodes as strings.  See <a
       href="Design/dom.html">Design/dom.html</a> for details.  There are less
       than 50 calls on <code>getNode</code> and <code>getActive</code>.  More
       work needs to be done in order to replace all (most?) uses of NodeList
       with cursors as well.
  <li> Extend Output so that it can take a Cursor instead of a Node, or even
       node components (node name, node type, attribute list, value string,
       and content).  It would be possible for a SAX parser or other
       event-driven parser to drive an Output directly at this point.
  <li> Add an event-driven interface to Processor -- essentially, make
       Processor into an Output.  This would
       require constructing subtrees for some (perhaps not all) active nodes.
       An alternative, event-oriented <code>action</code> method would
       probably be needed in the <code>Action</code> interface, or (more
       likely) a pair of them.  In the default case these would simply pass
       the event (in the form of a cursor) to the Output.  For <em>active</em>
       nodes, these would construct a subtree and call the original 3-argument
       <code>action</code> routine when the end tag is seen, but eventually
       many handlers would be rewritten for better performance.
  <li> It would be possible at this point to switch Parser from being an Input
       to being something that merely drives an Output.  
</ol>

<p> Note that if Output extends SAX, and Processor extends Output, it becomes
    possible to use the DPS to process XML delivered by a SAX parser.  You
    couldn't use it on documents with embedded DPS control structures or
    entities, but you <em>could</em> use it for other kinds of processing.
    Actually, you could use it for XXML as well if you had a way to avoid
    entities; this would have other advantages.  There are three possibilities:
<ol>
  <li> Add a constructor for elements, so that an attribute list could be
       built dynamically.  We need this anyway.
  <li> Define sub-elements as alternatives to <em>every</em> attribute.  We
       might not want this in all cases, but a small number of standard
       elements would cover the common ones (e.g. name, href, ...). 
  <li> Define a general-purpose sub-element to replace <em>any</em>
       attribute.  This could be handled in BasicHandler and GenericHandler,
       so it's much simpler than the previous alternative.
       <code>&lt;o&gt;</code> (for ``option'') comes to mind. 
</ol>

<p> The event-driven Processor is somewhat related to the old
    <em>Token</em>-oriented ``interform interpretor'' enshrined in
    <code>pia/src/java/crc/interform</code> -- not that it's a particularly
    good example.

<p> <a href="http://www.jclark.com/xml/xp/index.html">XP</a> is a fast XML
    parser written in Java by James Clark; it provides almost everything we
    need except that it doesn't seem to report external entities in attribute
    values.  (All of the DPS's entities are effectively external.)

<h3>PIA: Servlet and Apache</h3>

<p> The choices for the PIA are Servlet (which seems pretty obvious), EJB, and
    an Apache module.  There are two different choices within Servlet.

<ol>
  <li> The entire PIA (more specifically the Resolver) is a Servlet.  This
       allows the PIA's own Agent name resolution and proxying to work
       cleanly.  It reduces the parent server to a mere shell.

  <li> Each Agent is a Servlet.  This bypasses the Resolver, but has the
       potential to greatly clean up the interface between the server portion
       of the PIA and the Agents, and probably gets rid of a lot of junk on
       Transaction as well.
</ol>

<p> The best is probably a hybrid approach: the Resolver is a Servlet in its
    own right, but delegates the actual response (<code>respond</code> method)
    to <code>Agent</code>s that are <em>also</em> <code>Servlet</code>s.  This
    gives the option of wrapping ordinary third-party <code>Servlet</code>s as
    <code>Agent</code>s.  Essentially, both <code>Resolver.push</code> and
    <code>Agent.respond</code> would get replaced by
    <code>Servlet.service</code>.

<p> The Servlet package contains ServletRequest and ServletResponse interfaces
    that include most of the functionality of the PIA's Machine and
    Transaction classes.  The thread machinery of Transaction and much of
    Content would still be required, and it's not clear whether Servlet is
    adequate for dealing with proxying.  It's likely that we would have to
    retain Transaction in some form in order to support threads, XML
    representations, and some DPS features.

<p> An Apache module is most easily implemented using <code>mod_java</code>,
    but any design should allow a C version of the PIA to be dropped in
    instead.  Apache uses a unified transaction structure that contains
    <em>both</em> request and response information in one place.  (Of course,
    if the servlet interface is used, it becomes even easier to interface the
    PIA to <code>mod_java</code>.)


<h2><a name="C-port">C Port</a></h2>

<blockquote><strong>
  See <a href="porting.html">porting.html</a>
</strong></blockquote>

<p> We need to produce a sufficiently complete design sketch of a C/C++ port
    that some other group can take over the job.   

<h2><a name="XML-rep">Agents and Tagsets in XML</a></h2>

<blockquote><strong>
  This is in progress.
  See <a href="Design/xml-world.html">Design/xml-world.html</a>
</strong></blockquote>

<p> The goal here is to represent as many PIA internal objects as possible in
    XML; in other words, to be able to write and read them as XML documents.
    <em>(Agent and Namespace have been completed; Tagset is less critical
    since they are already defined in XML, so writing them out is less
    necessary.)</em>


<hr><!-- ========================================================== -->
<h2><a name="DOM">Improved Document Representation</a></h2>

<blockquote><strong>This is in progress.
  See <a href="Design/dom.html">Design/dom.html</a> </strong>
</blockquote>

<p> The goal here is to make the internal representation of parse trees
    conform completely to the W3C's Document Object Model <em>(this part has
    been completed as of 1999-04-15)</em>, and then to make the DPS almost
    completely independent of the DOM implementation by moving it to a
    cursor-based access model (<em>still in progress)</em>.


<hr><!-- ========================================================== -->
<h2>Language Improvements</h2>

<blockquote>

 <p> `When I use a word,' Humpty Dumpty said in rather a scornful tone, `it
     means just what I choose it to mean -- neither more nor less.' 

 <p> `The question is,' said Alice, `whether you <em>can</em> make words mean
     so many different things.'  

 <p> `The question is,' said Humpty Dumpty, `which is to be master - - that's
     all.'  
  <p> -- <em>Lewis Carrol</em>
</blockquote>

<h3>XML compliance</h3>

<p> For better or for worse, XML has moved farther apart from HTML.  Its
    proponents would like to drag HTML along for the ride, and use strict XML
    for <em>everything</em> on the Web.  I don't necessarily hold with this
    view, but as long as the PIA has been touted as an XML-based system we
    have to go along at least part of the way, and make our language as
    strictly XML-compliant as we can.

<p> At this point there are really only two places where we differ from XML:

<ol>
  <li> Our use of namespaces diverges a great deal from XML's, to the point
       where an XML application that is aware of namespaces might not be able
       to deal with our <code>.xh</code> files.  On the other hand it might;
       XML doesn't appear to recognize namespaces in entity names.
  <li> Our language was designed with SGML attribute minimization in mind.
       The resulting constructs (e.g. ``<code>foo="foo"</code>'' are often
       particularly ugly in XML.
</ol>

<h3>Namespaces</h3>

<p> In order to accomodate XML namespaces, we may want to use  a different
    character as our namespace separator.  Dash, period, and underscore are
    available; period would seem to be the best substitute.  

<h3>Attributes</h3>

<p> SGML allows attributes to be minimized in two different ways:
<ol>
  <li> an attribute with no value specified evaluates to its name
  <li> by requiring that enumerated values be unique across all the attributes
       of an element, an enumerated value can be assigned to its proper
       attribute
</ol>

<p> HTML makes use only of the first but, as we will see below, we can take
    advantage of the second in writing a cleanup tagset.

<p> There are basically five ways to ``pretty-up'' attributes:

<ol>
  <li> Move the offending attributes into tag names.  In other words, use
       &lt;test.zero&gt; instead of &lt;test zero&gt;.
  <li> Turn them from attribute names to values.  For example, transform
       &lt;numeric sum&gt; into &lt;numeric op="sum"&gt;.
  <li> Give their value a useful meaning.
  <li> Move from two attributes, one of which is boolean, to two attributes
       with values, one of which is optional.  An example from the
       <em>old</em> language was &lt;read file=<em>filename</em>&gt;
       vs. &lt;read href=<em>url</em>&gt;.
  <li> Move data from attributes to sub-elements.  We did that when we moved
       from &lt;repeat list=<em>list</em>&gt; to
       &lt;repeat&gt;&lt;foreach&gt;<em>list</em>
       &lt;/foreach&gt;&lt;/repeat&gt;.  
</ol>

<p> Most likely, some combination of all of these will be required in order to
    redesign the language so that it is both fully XML-compliant and easily
    human-readable.

<h4>Implementation Note</h4>

<p> <code>GenericHandler</code> already has a method called
    <code>dispatch</code> that can handle the first three methods above:  it
    will recognize a keyword either as an attribute name, the value of a
    specified attribute, or a suffix to the tag name.



<hr>
<b>Copyright &copy; 1997-1999 Ricoh Silicon Valley</b><br>
<b>$Id: roadmap.html,v 1.7 1999-06-17 00:06:18 steve Exp $</b><br>
<address><a href="http://rsv.ricoh.com/~steve/"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com"
         >steve@rsv.ricoh.com</a>&gt;</address>
</body></html>
