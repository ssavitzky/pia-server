<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>The Naming of Names</title>
<link rev="made" href="mailto:steve@rsv.ricoh.com">
</head><body>
<h1>The Naming of Names (Again)</h1>
<h2>Yet Another Great Renaming</h2>

<blockquote><em>
  For the previous (January-July 1999) version of this file, see
  <a href="Archives/naming.html">Archives/naming.html</a>.
</em></blockquote>

<h2>Parts of the PIA</h2>

<h3>That Was The Web That Was</h3>

<p> Up until now we have been regarding the PIA as a two-part system:  a
    specialized web server based on ``agents'', and a document processing
    engine used to implement active documents.  Agents, in turn, <em>also</em>
    had two aspects:  the ability to ``act on'' selected server transactions,
    and the ability to ``satisfy'' or ``handle'' transactions to particular
    URL's.

<p> All that is changed now, or soon will be.  A new millenium is upon us.

<blockquote>
    And what rough beast, its hour come 'round at last,<br>
    Slouches toward Bethlehem to be born?

    <p align=right><em>The Second Coming</em> by W. B. Yeats</p>
</blockquote>


<h3>The New World Order</h3>

<p> The PIA should now be regarded as a three-part system.

<ol>
  <li> As before, the mapping from SGML tags to corresponding actions is done
       by the document-processing engine, the DPS.

  <li> Also as before, the mapping from HTTP transactions to Agents that act
       on them is done by the Resolver.  The difference is that Agents no
       longer have anything to do with the mapping from URL's to documents or
       from (active) documents to tagsets.

  <li> The third component of the PIA is the mapping from URL's to documents.  
       Since agents are no longer associated with this process, it will
       significantly simplify the Agent interface.
</ol>

<h2>The PIA Site and its Sub-Sites</h2>

<p> A PIA server appears to the browser as a directory tree.  The top level of
    this tree is called the PIA's ``<dfn>site</dfn>'', and any subtree of a
    site is called a ``<dfn>subsite</dfn>''.

<p> The top level <em>directory</em> corresponding to a PIA site is called the
    site's ``<dfn>root</dfn>''.  To a first approximation, every top-level
    subsite of the PIA corresponds to a subdirectory of the root, and so on
    down the tree.  Each subsite directory contains a
    <code>subsite.config</code> file that describes its configuration.

<dl>
  <dt> <b>Note:</b>
  <dd> We probably want to reconsider the name <code>subsite.config</code>.
       It would, of course, be a configurable parameter, but we ought to make
       a good choice for the default. 
</dl>

<p> Many subsites in a working PIA are associated with agents; whether one
    chooses to refer to the <code>History</code> <em>agent</em> or the
    <code>/History</code> <em>subsite</em> depends a lot on which aspect you
    want to talk about.

<p> Similarly, many subsites contain both active documents (e.g. the forms
    used to configure and control an agent or group of agents) and data files.
    The convention is for the data files to be contained in a sub-subsite
    called <code>.../DATA/</code>. 

<p> Here is where the first-approximation equivalence between subsites and
    subdirectories breaks down:  it's possible for a subsite or a document to
    be ``virtual'' -- located in another place in the filesystem.  For
    example, one might want to make a photo album accessible by anonymous FTP,
    in which case one might make <code>/home/ftp/pub</code> appear in the
    site hierarchy as a virtual subsite of <code>/Photo-album</code> with the
    URL <code>/Photo-album/DATA</code> or <code>/Photo-album/Photos</code>.

<h3>PIA Startup</h3>

<p> The PIA starts up and looks for a suitable configuration file, using the
    following search list:

<ol>
  <li> The command line, which may specify <em>either</em> the pathname of the
       configuration file itself, or the site root directory and other
       information that might be in the configuration file.  
  <li> The $PIA_CONFIG environment variable.  Again, this might contain either
       the pathname of the configuration file, or a complete command line. 
  <li> A file called <code>pia.config</code> or <code>.pia-config</code> in
       one of the following places:
       <ol>
	 <li> the user's home directory
	 <li> the current directory
	 <li> $PIA_DIR ($PIA_HOME ?)
	 <li> .. relative to the binary of the <code>pia</code> command; it is
	      expected that this will be ...<code>/PIA</code>.
       </ol>
</ol>

<p> <code>PIA/pia-config</code> will, of course, exist; it will designate
    <code>PIA/MySite</code> as the site root.  On a multi-user system, if
    PIA/MySite is not in the user's home directory or is not writable by the
    user, the pia's home page will contain a form for making a copy.

<p> It is possible that <code>PIA/MySite</code> might not exist, either
    because it hasn't been installed (it is generated, after all) or because
    it has been removed.  It would be possible in that case to construct a
    virtual root that points to the default directory; this effectively
    duplicates the process by which <code>MySite</code> is created.  However,
    it will almost certainly be better to treat this as an error, just as in
    any other case where the specified root does not exist. 

<p> Once the PIA's root directory has been located, all of its active subsites
    that contain agents can be initialized.

<h3>Site Creation</h3>

<p> One way to create a site, of course, would be to blindly copy
    <code>PIA/MySite</code> out of the installation.  This sidesteps the
    question of how <code>MySite</code> gets created in the first place.

<p> The obvious way to create <em>any</em> subsite directory is to start with
    a <em>virtual</em> subsite (or, equivalently, a reference to a subsite
    directory) and <em>realize</em> it.  This process consists of the
    following steps:

<ol>
  <li> Create the real directory
  <li> Copy a <code>site.config</code> file if it has one.
  <li> Create a <em>modified</em> <code>subsite.config</code> file that puts
       the original directory in the default search path, but copies
       everything else.
  <li> Create a new <code>README.html</code> file containing the date, user's
       name, and the pathname of the original directory.
</ol>

<p> One can go on to recursively realize more documents and subsites at this
    point. 


<h3>Documents and Sheaves</h3>

<p> The set of documents and subsites bound together at a subsite is called a
    ``<dfn>sheaf</dfn>'' of documents.  A sheaf is distinguished from a
    directory in that it may contain virtual and imaginary entries as well as
    real ones.  Note that a symbolic link doesn't quite capture the idea of a
    virtual document.

<blockquote><em>
    We need to take more than a cursory look at WebDAV, since the idea of
    XML-based metadata and file manipulation is very much the same idea as
    what we're considering here.
</em></blockquote>

<p> A directory's <code>subsite.config</code> file contains the following:

<ol>
  <li> Normal variables.  These correspond pretty much to the current Agent
       state, and are inherited by (i.e. accessible to) all active documents
       underneath the subsite.  These include things like the extension
       mapping.  Normal namespace scoping provides inheritance; constructs
       like <code>..:foo</code> can be used to navigate the tree. 
  <li> Document descriptors.  Strictly speaking these are contained in a local
       variable (perhaps called SHEAF); they describe any virtual or imaginary
       documents and subsites.  Note that <em>real</em> documents and subsites
       do not need to be described explicitly unless they have non-default
       attributes. 
</ol>

<p> It's important to note that if any of the variables associated with a
    virtual subsite is changed, the subsite (and all of its parents) must be
    realized at that point in order to have a suitable real directory in
    which to store the modified <code>subsite.config</code> file.

<p> Note that information about a subsite is actually contained in three
    places that have to be merged:

<ol>
  <li> its <code>subsite.conf</code> file
  <li> its <em>parent's</em> <code>subsite.conf</code> file
  <li> its parent's <em>directory</em>. 
</ol>

<p> There are some problems with setting variables: it's not clear exactly
    when, or even whether, to synchronize an internal cache with the
    <code>subsite.conf</code> file that contains a subsite's permanent
    bindings.  Obviously it would be a lot less confusing for users if this
    happened invisibly.  It may be useful to designate some variables as
    volatile.


<h2>Subsite and Document Types</h2>

<p> Subsites and documents are distinguished along three axes:
<ol>
  <li> Reality -- the extent to which they correspond to real subdirectories
       or real files descended from the root.
  <li> Activity -- the extent to which they are processed by tagsets, and the
       extent to which these tagsets can influence the state and behavior of
       the PIA.
  <li> Visibility -- the extent to which they are visible outside the PIA.
</ol>


<h3>Real, Virtual, and Imaginary</h3>

<p> There are three different kinds of subsite:

<ol>
  <li> <em>Real</em> subsites.  <br>
       A <em>real</em> subsite corresponds to an actual subdirectory
       descending from the site's root directory.  A real subsite may contain
       a <code>subsite.config</code> file, an XML file that describes the
       contents of the subsite and how they are to be processed.  In
       particular, it defines the mapping between filenames and tagsets.
  <li> <em>Virtual</em> subsites. <br>
       A <em>virtual</em> subsite is something like a symbolic link: it
       consists of a real directory, containing a <code>subsite.config</code>
       file, but it is not a descendent of the root.  Instead, it is ``bound
       in'' or ``mounted'' by means of an entry in its parent's
       <code>subsite.config</code> file.  A Virtual subsite can be effectively
       ``realized'' by simply copying it into its real parent. 
  <li> <em>Imaginary</em> subsites <br>
       An <em>imaginary</em> subsite is <em>completely</em> ``unreal'' -- it
       does not correspond to a real directory anywhere, but is constructed by
       a program out of thin air.  This is somewhat like the "/proc"
       filesystem on Linux. 
</ol>

<p> Similarly, a single subsite may consist of a combination of real, virtual,
    and imaginary <em>documents</em>.  Note that even a real subsite may
    contain virtual files, for example files taken from a directory full of
    defaults.  Such virtual documents and subsites can be specified either
    individually by name, or collectively by means of a <em>search path</em>.

<p> For example, the directory listing of a file with no
    <code>index.html</code> file is an imaginary file, as is the error
    document returned by a web server when a non-existent file is requested.

<h3>Active and Passive</h3>

<p> Another way of distinguishing subsites, completely orthogonal to the
    reality axis, is the activity axis.

<ol>
  <li> <em>Active</em> subsites<br>
       May contain their own <code>subsite.config</code> file, as may any
       active descendent.  
  <li> <em>Passive</em> subsites<br>
       are ``locked'' -- any <code>subsite.config</code> file they or any of
       their descendents may contain is ignored, and only ``safe'' tagsets may
       be used to process files in them.  Data directories, for example, are
       almost invariably passive; otherwise someone who knew the PIA's naming
       conventions might be able to deposit an XML virus in a cache (for
       example) and have it executed. 
</ol>

<p> (At some point we may want to distinguish two levels of passivity:
    processed only by safe tagsets, and totally unprocessed.  We may also end
    up with two levels of activity:  requiring agent initialization, and
    normal.) 

<p> Documents are also distinguished by activity:

<ul>
  <li> <em>Active</em> files <br>
       are processed by some tagset before being delivered to a browser.
  <li> <em>Passive</em> files <br>
       are delivered to a browser without processing. 
</ul>


<h3>Visible and Invisible</h3>

<p> Finally, documents and even subsites may be distinguished by whether they
    are visible or invisible from a browser.  Note that it is perfectly
    meaningful for a subsite (even a virtual one) to be invisible -- this just
    means that it can be accessed from an active document (e.g. as an external
    entity or through an <code>&lt;include&gt;</code> tag) but not by the
    user. 

<h2>Agents</h2>


<hr>
<b>Copyright &copy; 1999 Ricoh Silicon Valley</b><br>
<b>$Id: naming.html,v 1.11 1999-07-22 20:38:41 steve Exp $</b><br>
<address><a href="http://rsv.ricoh.com/~steve/"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com"
         >steve@rsv.ricoh.com</a>&gt;</address>
</body></html>
