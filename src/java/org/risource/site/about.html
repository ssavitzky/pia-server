<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>About the Site Resource Package</title>
</head><body>
<h1>About the Site Resource Package</h1>

<h3>See Also</h3>
<ul>
  <li> <a href="to-do.html">to-do.html</a>
  <li> <a href="../pia/to-do.html">../pia/to-do.html</a>
  <li> <a href="../../../../../Doc/Notes/steve/naming.html">Steve's notes</a>
</ul>

<h2>Introduction</h2>

<p> The Site Resource Package is designed to implement the mapping from URL's
    passed to the PIA server, to documents returned by the browser.  This
    breaks down into the following steps:

<ol>
  <li> Mapping from the file part of the URL to the corresponding document
       resource in the server's filesystem.
  <li> Mapping the resource into a content type, processing method (none, DPS,
       or CGI), and (in the case of DPS processing) tagset.
</ol>

<p> Additionally, the Site Resource Package is able to manage an arbitrary
    amount of additional XML metadata associated with documents, including
    WebDAV properties, DPS entities, PIA agents, and so on.

<p> The information that defines the structure (configuration) of a site is
    <em>also</em> defined using XML, but configuration information is kept (at
    least conceptually) separate from other metadata in order to simplify the
    implementation and increase versatility.

<h2>Class Structure</h2>

<p> There are three interfaces in the <code>org.risource.site</code> package:

<ol>
  <li> <a href="Resource.java">Resource</a>: the generic interface for any
       kind of resource on a site.
  <li> <a href="Document.java">Document</a>: the interface for document (leaf)
       resources.
  <li> <a href="Root.java">Root</a>: the interface for the root of a site. 
</ol>

<p> The interfaces follow the the <strong>Composite</strong> pattern as
    described in the Gang-of-Four book; in this pattern the main interface
    (Resource) includes all methods needed for accessing sub-Resources.  This
    imposes no burden on implementations of Document, which are free to return
    null results. 

<p> However, since every container (directory) Resource has an associated
    Document (for example, <code>home.xh</code> or <code>index.html</code>)
    that may be accessible on its own, it makes sense for Resource and
    Document to be different.  A method, <code>getDocument</code>, gets the
    Document associated with a Resource (even if it is the same object). 

<p> There are two parallel sets of implementation classes:
<p>
<table border=2 cellpadding=3 align=center>
  <tr><th>&nbsp;</th>
      <td align=center colspan=2>AbstractResource</td>
  </tr>
  <tr><th>&nbsp;</th>
      <td>ConfiguredResource</td>
      <td>&nbsp;</td>
  </tr>
  <tr><th>Resource</th>
      <td>Subsite <em>(container)</em></td>
      <td>FileResource</td>
  </tr>
  <tr><th>Document</th>
      <td>LocalDocument</td>
      <td>FileDocument</td>
  </tr>
  <tr><th>Root</th>
      <td>Site</td>
      <td>&nbsp;</td>
  </tr>
</table>

<p> The ``File'' classes are (comparatively) lightweight objects that contain
    no configuration information or associated XML metadata -- everything is
    derived from the underlying file or directory.

<p> One may well ask why the interface is called Resource and the
    implementation is called Subsite rather than the other way around, or
    perhaps something like BasicResource.  The main reason is that
    ``<code>site.Resource</code>'' simply <em>sounds better</em> than
    ``<code>site.Subsite</code>''.  Also, ``resource'' (and to a lesser
    extent, ``document'') match the terminology used in, for example, WebDAV
    and most other web-related specifications.  (URL, after all, stands for
    ``Universal <em>Resource</em> Locator''.)

<p> <code>Subsite</code> caches a large amount of information: virtual search
    path for defaults, which virtual directory each child is in, timestamps,
    tagsets, configuration information for child documents, and so on.  In
    fact, it is possible to build an entire virtual Site out of nothing but a
    configuration file.

<p> For this reason, Subsite objects are normally kept in memory as a tree.
    FileResource objects are not, since they are easy to reconstruct from the
    available filesystem information.  Similarly, LocalDocument objects are
    easily reconstructed from a combination of filesystem information and
    the configuration information cached by their parent Subsite.

<h2>Location</h2>

<p> A Resource has a ``real'' location in the filesystem, which is a direct
    descendent of the directory that corresponds to the Root resource.  A
    container resource may also have a ``virtual search path'' of directories
    in which to look for default children.  All writing is done in the real
    location. 

<p> Typically the virtual search path of a resource has only two elements: a
    ``prototype'' directory under the source-controlled PIA directory, and a
    ``defaults'' directory that provides a fallback for documents like
    <code>home.xh</code> which most directories are expected to have.  The
    prototype directory corresponds roughly to <code>PIA/Agents</code>, and
    most or all actual agents will have their prototype directories
    <em>in</em> <code>PIA/Agents</code>.  The prototype for the standard,
    out-of-the-box configuration ought to be <code>PIA</code> itself.

<p> The real location of the PIA's root corresponds rather closely to the
    current <code>.pia</code> directory.  It is created in the first place by
    specifying a ``configuration document'' for the Site (see below) and then
    ``realizing'' it.  A command-line utility will be provided for this
    purpose.

<p> There will be multiple sample configuration files in the standard
    distribution, corresponding to, e.g., an appliance server, a personal
    proxy, and so on.  A distribution of the PIA could ship with a real,
    non-CVS-controlled <code>Site</code> directory created by realizing a
    default configuration as part of the release process.  It might be best if
    this were a <em>sibling</em> of the <code>PIA</code> directory rather than
    a child; another possibility is to create it on installation (which would
    allow the user to select their preferred configuration).  Most Unix users
    will, of course, want to use <code>~/.pia</code> as the real location of
    their personal PIA.

<h2>Configuration</h2>

<p> A Resource's ``configuration'' is specified using an XML element with node
    type ``<code>Resource</code>''.  Attributes specify all of the String,
    boolean, and integer fields of the underlying object (of class Subsite or
    Document.  XML metadata is contained in <code>namespace</code> elements in
    the content.

<p> The configuration of a Container resource may also contain
    <code>Resource</code> sub-elements in its content, corresponding to
    documents and virtual containers that have no corresponding configuration
    file.  A Subsite will normally have its configuration loaded from a file
    called, by default, ``<code>_subsite.xcf</code>''.

<dl>
  <dt> <b>Note:</b>
  <dd> <em>Although hooks are in place for XML configuration information, the
       loading and saving of this information is presently unimplemented.</em> 
</dl>


<h2>Agents</h2>

<p> One objective of the <code>site</code> package is to provide the machinery
    necessary to support ``agents,'' but without placing any constraints on
    their implementation.  All that a Root really needs to do is to map names
    that start with a ``<code>~</code>'' (tilde) character into the ``home
    Resource'' (typically a container) for the named agent.  It is then up to
    the documents in that Resource to provide the agent's user interface.

<p> Note that not all agents need to be registered in this way, only the ones
    that need web-accessible user interfaces.  Similarly, nothing prevents a
    Resource from being the home of several agents, as long as some mechanism
    exists for sorting them out.  One way of doing this might be to make an
    Agent's ``home Resource'' a document rather than a container, but this may
    complicate things unnecessarily.  For the moment we can ignore the
    problem, and simply make sure that every agent has its own home.

<p> In the new PIA, then, agents will be considerably simpler than in the old
    scheme, because they will no longer have anything to do with interpreting
    URL's or processing documents.  Essentially, an agent will be nothing but
    an XML namespace with a binding for <code>action</code> or
    <code>act-on</code> that provides the hook.  An agent will correspond very
    directly to the document resource its state is kept in (the
    <code>AGENT.xml</code> file.

<p> Note that an agent's state document is <em>contained in</em> its home
    resource, along with all the other forms that manipulate the agent.  We
    might want to have a specialized kind of Document for agents in order to
    make state-saving more efficient; a better alternative might be to
    classify the Agent's state as metadata -- there are already hooks in place
    to save metadata.  We also ought to change the filename extension to take
    advantage of the extension-to-tagset mapping.  An alternative would be to
    put the tagset in the configuration.

<hr>
<b>Copyright &copy; 1997-1999 Ricoh Silicon Valley</b><br>
<b>$Id: about.html,v 1.5 1999-08-23 21:50:58 steve Exp $</b><br>
<address><a href="http://rsv.ricoh.com/~steve/"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com"
         >steve@rsv.ricoh.com</a>&gt;</address>
</body></html>
